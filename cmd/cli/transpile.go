// Package cli provides transpilation commands for GASType
package cli

import (
	"encoding/json"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/rafa-mori/gastype/internal/astutil"
	transpiler "github.com/rafa-mori/gastype/internal/engine"
	gl "github.com/rafa-mori/gastype/internal/module/logger"
	"github.com/rafa-mori/gastype/internal/pass"

	"github.com/spf13/cobra"
)

// TranspileConfig holds configuration for transpilation operations
type TranspileConfig struct {
	InputPath      string `json:"input_path"`
	OutputPath     string `json:"output_path"`
	Mode           string `json:"mode"`          // "analyze", "transpile", "both", "full-project"
	OutputFormat   string `json:"output_format"` // "json", "yaml", "text"
	Verbose        bool   `json:"verbose"`
	SecurityLevel  int    `json:"security_level"` // 1=low, 2=medium, 3=high
	PreserveDocs   bool   `json:"preserve_docs"`
	BackupOriginal bool   `json:"backup_original"`
	NoObfuscate    bool   `json:"no_obfuscate"` // Stage 1: transpile without obfuscation
	MapFile        string `json:"map_file"`     // Path to context mapping file

	// Engine-specific configurations
	DryRun       bool     `json:"dry_run"`       // Only analyze, don't save files
	EstimatePerf bool     `json:"estimate_perf"` // Estimate performance gains
	Passes       []string `json:"passes"`        // List of passes to apply
}

// generatePreservedMainFile preserves the original main.go structure while adding optimizations
func generatePreservedMainFile(filename string, contexts []transpiler.LogicalContext, generator *transpiler.AdvancedCodeGenerator) (string, error) {
	// For now, we will simulate the original content
	originalContent, err := os.ReadFile(filename)
	if err != nil {
		gl.Log("error", fmt.Sprintf("error reading original file %s: %v", filename, err))
		return "", fmt.Errorf("error reading original file %s: %w", filename, err)
	}

	var output strings.Builder

	// Header with comment
	output.WriteString("// Generated by GASType  Transpiler\n")
	output.WriteString(fmt.Sprintf("// Source: %s\n", filename))
	output.WriteString("// PRESERVED MAIN STRUCTURE with bitwise optimizations\n\n")

	// Write package declaration
	output.WriteString("package main\n\n")

	// Parse and modify the original content to preserve package and imports
	originalStr := string(originalContent)
	lines := strings.Split(originalStr, "\n")

	// Find package declaration and imports
	inImports := false
	for _, line := range lines {
		trimmed := strings.TrimSpace(line)

		// Preserve package declaration
		if strings.HasPrefix(trimmed, "package ") {
			output.WriteString(line + "\n")
			continue
		}

		// Preserve imports
		if strings.HasPrefix(trimmed, "import ") || trimmed == "import (" {
			output.WriteString(line + "\n")
			inImports = true
			continue
		}

		if inImports {
			output.WriteString(line + "\n")
			if trimmed == ")" {
				inImports = false
				output.WriteString("\n")
			}
			continue
		}

		// Preserve global variables but add optimization comment
		if strings.HasPrefix(trimmed, "var ") && !strings.Contains(line, "func") {
			output.WriteString("// Optimized global variable\n")
			output.WriteString(line + "\n")
			continue
		}

		// Preserve main function but add optimizations
		if strings.Contains(trimmed, "func main()") {
			output.WriteString("// main function with GASType optimizations enabled\n")
			output.WriteString(line + "\n")
			continue
		}

		// Preserve other function calls and logic
		if trimmed != "" && !strings.HasPrefix(trimmed, "//") {
			output.WriteString(line + "\n")
		} else if strings.HasPrefix(trimmed, "//") {
			// Preserve comments
			output.WriteString(line + "\n")
		}
	}

	return output.String(), nil
}

type FullProjectStats struct {
	StartTime          time.Time     `json:"start_time"`
	EndTime            time.Time     `json:"end_time"`
	Duration           time.Duration `json:"duration"`
	TotalFiles         int           `json:"total_files"`
	GoFiles            int           `json:"go_files"`
	TranspiledFiles    int           `json:"transpiled_files"`
	ContextsFound      int           `json:"contexts_found"`
	ContextsTranspiled int           `json:"contexts_transpiled"`
	OptimizationLevel  string        `json:"optimization_level"`
	ObfuscationLevel   string        `json:"obfuscation_level"`
	Errors             []string      `json:"errors,omitempty"`
	Warnings           []string      `json:"warnings,omitempty"`
}

// transpileCmd creates the main transpile command
func transpileCmd() *cobra.Command {
	var config TranspileConfig

	// Initialize Passes slice with defaults
	config.Passes = []string{"revolution"}

	cmd := &cobra.Command{
		Use:   "transpile",
		Short: "Transpile Go code to bitwise-optimized equivalent",
		Long: `Transpile traditional Go code to bitwise-optimized equivalent using AST analysis.

		This command analyzes Go source code and identifies optimization opportunities:
		- Boolean struct fields ‚Üí Bitwise flags
		- If/else chains ‚Üí Jump tables
		- String literals ‚Üí Byte arrays (security)
		- Configuration structs ‚Üí Flag systems

		The transpiler can operate in different modes:
		- analyze: Only analyze and report optimization opportunities
		- transpile: Generate transpiled code files
		- both: Analyze and generate transpiled code
		- full-project: Complete project transpilation with build system
		- staged-transpile: Multi-stage transpilation (clean ‚Üí validate ‚Üí obfuscate)

		Examples:
		  gastype transpile -i ./src -o ./src_optimized -m transpile
		  gastype transpile -i ./config.go -m analyze --format json
		  gastype transpile -i ./project -m both --security 3 --verbose
		  gastype transpile -i ./TESTES/gobe -o ./gobe_transpiled -m full-project --security 3
		  gastype transpile -i ./src -o ./out_optimized --no-obfuscate -v (Stage 1)`,

		RunE: func(cmd *cobra.Command, args []string) error {
			return runTranspileCommand(&config)
		},
	}

	// Input/Output flags
	cmd.Flags().StringVarP(&config.InputPath, "input", "i", ".",
		"Input directory or file containing Go code to analyze/transpile")
	cmd.Flags().StringVarP(&config.OutputPath, "output", "o", "./gastype_output",
		"Output directory for transpiled code and analysis results")

	// Mode and format flags
	cmd.Flags().StringVarP(&config.Mode, "mode", "m", "analyze",
		"Operation mode: analyze, transpile, both, full-project, staged-transpile")
	cmd.Flags().StringVar(&config.OutputFormat, "format", "json",
		"Output format for analysis results: json, yaml, or text")

	// Optimization flags
	cmd.Flags().IntVar(&config.SecurityLevel, "security", 2,
		"Security optimization level (1=low, 2=medium, 3=high)")
	cmd.Flags().BoolVar(&config.PreserveDocs, "preserve-docs", true,
		"Preserve original comments and documentation in transpiled code")
	cmd.Flags().BoolVar(&config.BackupOriginal, "backup", true,
		"Create backup of original files before transpilation")

	// Pipeline flags
	cmd.Flags().BoolVar(&config.NoObfuscate, "no-obfuscate", false,
		"Stage 1: Transpile without obfuscation (readable optimized code)")
	cmd.Flags().StringVar(&config.MapFile, "map", "",
		"Generate context mapping JSON file for transpilation tracking")

	// Engine flags
	cmd.Flags().BoolVar(&config.DryRun, "dry-run", false,
		"Run transpilation in dry-run mode without modifying files")
	cmd.Flags().BoolVar(&config.EstimatePerf, "estimate-perf", false,
		"Estimate performance impact of transpilation")
	cmd.Flags().StringSliceVar(&config.Passes, "passes", config.Passes,
		"Specify transpilation passes to run (comma-separated)")

	// Utility flags
	cmd.Flags().BoolVarP(&config.Verbose, "verbose", "v", false,
		"Show detailed logs of analysis and transpilation process")

	return cmd
}

// runTranspileCommand executes the transpilation process
func runTranspileCommand(config *TranspileConfig) error {
	if config.Verbose {
		gl.Log("info", fmt.Sprintf("üöÄ Starting GASType transpilation in mode: %s", config.Mode))
		gl.Log("info", fmt.Sprintf("üìÅ Input: %s", config.InputPath))
		gl.Log("info", fmt.Sprintf("üìÅ Output: %s", config.OutputPath))
	}

	// Check if using new engine architecture
	if config.DryRun || config.EstimatePerf || len(config.Passes) > 0 {
		return runEngineTranspilation(config)
	}

	// Validate input path
	inputInfo, err := os.Stat(config.InputPath)
	if err != nil {
		gl.Log("error", fmt.Sprintf("error accessing input path %s: %v", config.InputPath, err))
		return fmt.Errorf("error accessing input path %s: %w", config.InputPath, err)
	}

	// For real transpilation mode, delegate immediately to avoid creating unwanted directories
	if config.NoObfuscate && (config.Mode == "transpile" || config.Mode == "both") {
		return performRealTranspilation(config)
	}

	// Create output directory if it doesn't exist (for traditional pipeline)
	if err := os.MkdirAll(config.OutputPath, 0755); err != nil {
		gl.Log("error", fmt.Sprintf("error creating output directory: %v", err))
		return fmt.Errorf("error creating output directory: %w", err)
	}

	// Initialize the bitwise transpiler
	bitwiseTranspiler := transpiler.NewBitwiseTranspiler()

	var results []transpiler.TranspilationResult

	if inputInfo.IsDir() {
		// Analyze entire project
		if config.Verbose {
			gl.Log("info", "üîç Analyzing project directory...")
		}
		results, err = bitwiseTranspiler.AnalyzeProject(config.InputPath)
		if err != nil {
			gl.Log("error", fmt.Sprintf("error analyzing project: %v", err))
			return fmt.Errorf("error analyzing project: %w", err)
		}
	} else {
		// Analyze single file
		if config.Verbose {
			gl.Log("info", "üîç Analyzing single file...")
		}
		result, err := bitwiseTranspiler.AnalyzeFile(config.InputPath)
		if err != nil {
			gl.Log("error", fmt.Sprintf("error analyzing file: %v", err))
			return fmt.Errorf("error analyzing file: %w", err)
		}
		if len(result.Optimizations) > 0 {
			results = append(results, *result)
		}
	}

	// Process results based on mode
	switch config.Mode {
	case "analyze":
		return outputAnalysisResults(results, config)
	case "transpile":
		return performTranspilation(results, config)
	case "both":
		if err := outputAnalysisResults(results, config); err != nil {
			return err
		}
		return performTranspilation(results, config)
	case "full-project":
		return performFullProjectTranspilation(config)
	case "staged-transpile":
		return performStagedTranspilation(config)
	default:
		return fmt.Errorf("invalid mode: %s (must be 'analyze', 'transpile', 'both', 'full-project', or 'staged-transpile')", config.Mode)
	}
}

// outputAnalysisResults outputs the analysis results in the specified format
func outputAnalysisResults(results []transpiler.TranspilationResult, config *TranspileConfig) error {
	if len(results) == 0 {
		if config.Verbose {
			gl.Log("info", "‚úÖ No optimization opportunities found")
		}
		return nil
	}

	// Create analysis summary
	summary := createAnalysisSummary(results)

	switch config.OutputFormat {
	case "json":
		return outputJSON(results, summary, config)
	case "yaml":
		return outputYAML(results, summary, config)
	case "text":
		return outputText(results, summary, config)
	default:
		return fmt.Errorf("invalid output format: %s", config.OutputFormat)
	}
}

// performTranspilation generates the actual transpiled code
func performTranspilation(results []transpiler.TranspilationResult, config *TranspileConfig) error {
	if config.Verbose {
		gl.Log("info", "üîß Generating transpiled code...")
	}

	// TODO: Implement actual code generation
	// For now, create placeholder files showing what would be generated

	for _, result := range results {
		if err := generateTranspiledFile(result, config); err != nil {
			return fmt.Errorf("error generating transpiled file for %s: %w",
				result.OriginalFile, err)
		}
	}

	if config.Verbose {
		gl.Log("info", fmt.Sprintf("‚úÖ Generated %d transpiled files", len(results)))
	}

	return nil
}

// createAnalysisSummary creates an overall summary of analysis results
func createAnalysisSummary(results []transpiler.TranspilationResult) map[string]interface{} {
	totalOptimizations := 0
	totalBytesSaved := 0
	totalSpeedupFactor := 0.0
	securityFeatures := 0

	for _, result := range results {
		totalOptimizations += len(result.Optimizations)
		for _, opt := range result.Optimizations {
			totalBytesSaved += opt.BytesSaved
			totalSpeedupFactor += opt.SpeedupFactor
		}
		securityFeatures += len(result.SecurityFeatures)
	}

	averageSpeedup := 1.0
	if totalOptimizations > 0 {
		averageSpeedup = totalSpeedupFactor / float64(totalOptimizations)
	}

	return map[string]interface{}{
		"files_analyzed":         len(results),
		"total_optimizations":    totalOptimizations,
		"estimated_bytes_saved":  totalBytesSaved,
		"average_speedup_factor": averageSpeedup,
		"security_features":      securityFeatures,
		"timestamp":              "2025-08-04", // Would use time.Now() in real implementation
	}
}

// outputJSON outputs analysis results in JSON format
func outputJSON(results []transpiler.TranspilationResult, summary map[string]interface{}, config *TranspileConfig) error {
	outputFile := filepath.Join(config.OutputPath, "analysis_results.json")

	output := map[string]interface{}{
		"summary": summary,
		"results": results,
	}

	data, err := json.MarshalIndent(output, "", "  ")
	if err != nil {
		gl.Log("error", fmt.Sprintf("error marshaling JSON: %v", err))
		return fmt.Errorf("error marshaling JSON: %w", err)
	}

	if err := os.WriteFile(outputFile, data, 0644); err != nil {
		gl.Log("error", fmt.Sprintf("error writing JSON file: %v", err))
		return fmt.Errorf("error writing JSON file: %w", err)
	}

	if config.Verbose {
		gl.Log("info", fmt.Sprintf("üìÑ Analysis results saved to: %s", outputFile))
	}

	return nil
}

// outputYAML outputs analysis results in YAML format
func outputYAML(results []transpiler.TranspilationResult, summary map[string]interface{}, config *TranspileConfig) error {
	// TODO: Implement YAML output
	gl.Log("error", "YAML output not yet implemented")
	return fmt.Errorf("YAML output not yet implemented")
}

// outputText outputs analysis results in human-readable text format
func outputText(results []transpiler.TranspilationResult, summary map[string]interface{}, config *TranspileConfig) error {
	outputFile := filepath.Join(config.OutputPath, "analysis_results.txt")

	var content string
	content += "üöÄ GASType Bitwise Analysis Results\n"
	content += "=====================================\n\n"

	// Summary section
	content += "üìä Summary:\n"
	content += fmt.Sprintf("  Files analyzed: %v\n", summary["files_analyzed"])
	content += fmt.Sprintf("  Total optimizations: %v\n", summary["total_optimizations"])
	content += fmt.Sprintf("  Estimated bytes saved: %v\n", summary["estimated_bytes_saved"])
	content += fmt.Sprintf("  Average speedup factor: %.2fx\n", summary["average_speedup_factor"])
	content += fmt.Sprintf("  Security features: %v\n", summary["security_features"])
	content += "\n"

	// Detailed results
	for i, result := range results {
		content += fmt.Sprintf("üìÅ File %d: %s\n", i+1, result.OriginalFile)
		content += fmt.Sprintf("  Optimizations found: %d\n", len(result.Optimizations))

		for j, opt := range result.Optimizations {
			content += fmt.Sprintf("    %d. %s\n", j+1, opt.Description)
			content += fmt.Sprintf("       Type: %s\n", opt.Type)
			content += fmt.Sprintf("       Location: %s\n", opt.Location)
			content += fmt.Sprintf("       Bytes saved: %d\n", opt.BytesSaved)
			content += fmt.Sprintf("       Speedup: %.2fx\n", opt.SpeedupFactor)
		}

		if len(result.SecurityFeatures) > 0 {
			content += "  Security features:\n"
			for j, feature := range result.SecurityFeatures {
				content += fmt.Sprintf("    %d. %s (%s)\n", j+1, feature.Description, feature.Strength)
			}
		}
		content += "\n"
	}

	if err := os.WriteFile(outputFile, []byte(content), 0644); err != nil {
		gl.Log("error", fmt.Sprintf("error writing text file: %v", err))
		return fmt.Errorf("error writing text file: %w", err)
	}

	if config.Verbose {
		gl.Log("info", fmt.Sprintf("üìÑ Analysis results saved to: %s", outputFile))
	}

	return nil
}

// performRealTranspilation executes real bitwise transpilation without obfuscation
func performRealTranspilation(config *TranspileConfig) error {
	if config.Verbose {
		gl.Log("info", "üîÑ STARTING REAL TRANSPILATION (Stage 1: no obfuscation)")
		gl.Log("info", fmt.Sprintf("üìÅ Input: %s", config.InputPath))
		gl.Log("info", fmt.Sprintf("üìÅ Output: %s", config.OutputPath))
	}

	// Create transpilation context
	ctx := astutil.NewContext(config.InputPath, config.OutputPath, !config.NoObfuscate, config.MapFile)

	// Initialize the real transpiler with context
	realTranspiler := transpiler.NewRealBitwiseTranspilerWithContext(ctx)

	// Check if input is a file or directory
	inputInfo, err := os.Stat(config.InputPath)
	if err != nil {
		gl.Log("error", fmt.Sprintf("error accessing input path %s: %v", config.InputPath, err))
		return fmt.Errorf("error accessing input path: %w", err)
	}

	if inputInfo.IsDir() {
		// Transpile entire directory
		gl.Log("info", "üìÅ Transpiling project directory...")

		// Create output directory
		if err := os.MkdirAll(config.OutputPath, 0755); err != nil {
			gl.Log("error", fmt.Sprintf("error creating output directory: %v", err))
			return fmt.Errorf("error creating output directory: %w", err)
		}

		return transpileDirectory(realTranspiler, config.InputPath, config.OutputPath, config)
	} else {
		// Transpile single file
		gl.Log("info", "üìÅ Transpiling single file...")

		// For single file, check if output path is a file or directory
		var outputFile string
		if strings.HasSuffix(config.OutputPath, ".go") {
			// Output is a specific file
			outputFile = config.OutputPath
			// Create output directory if needed
			if err := os.MkdirAll(filepath.Dir(outputFile), 0755); err != nil {
				gl.Log("error", fmt.Sprintf("error creating output directory: %v", err))
				return fmt.Errorf("error creating output directory: %w", err)
			}
		} else {
			// Output is a directory
			if err := os.MkdirAll(config.OutputPath, 0755); err != nil {
				gl.Log("error", fmt.Sprintf("error creating output directory: %v", err))
				return fmt.Errorf("error creating output directory: %w", err)
			}
			outputFile = filepath.Join(config.OutputPath, filepath.Base(config.InputPath))
		}

		if err := realTranspiler.TranspileFile(config.InputPath, outputFile); err != nil {
			gl.Log("error", fmt.Sprintf("transpilation failed: %v", err))
			return fmt.Errorf("transpilation failed: %w", err)
		}

		gl.Log("info", fmt.Sprintf("‚úÖ Transpilation complete: %s ‚Üí %s", config.InputPath, outputFile))
		return nil
	}
}

// transpileDirectory recursively transpiles a directory
func transpileDirectory(realTranspiler *transpiler.RealBitwiseTranspiler, inputDir, outputDir string, config *TranspileConfig) error {
	gl.Log("info", fmt.Sprintf("üîç Scanning directory: %s", inputDir))

	transpiledCount := 0
	copiedCount := 0

	err := filepath.Walk(inputDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Calculate relative path and target path
		relPath, err := filepath.Rel(inputDir, path)
		if err != nil {
			return err
		}
		targetPath := filepath.Join(outputDir, relPath)

		// Create directories
		if info.IsDir() {
			return os.MkdirAll(targetPath, info.Mode())
		}

		// Handle .go files with transpilation
		if strings.HasSuffix(info.Name(), ".go") {
			gl.Log("info", fmt.Sprintf("  üîÑ Transpiling: %s", relPath))
			if err := realTranspiler.TranspileFile(path, targetPath); err != nil {
				gl.Log("error", fmt.Sprintf("    ‚ö†Ô∏è  Transpilation failed, copying original: %v", err))
				// Fallback to copying original file
				if err := copyFile(path, targetPath); err != nil {
					gl.Log("error", fmt.Sprintf("    ‚ö†Ô∏è  Failed to copy file %s: %v", path, err))
					return fmt.Errorf("failed to copy file %s: %w", path, err)
				}
				copiedCount++
			} else {
				transpiledCount++
			}
		} else {
			// Copy non-Go files as-is
			if err := copyFile(path, targetPath); err != nil {
				gl.Log("error", fmt.Sprintf("    ‚ö†Ô∏è  Failed to copy file %s: %v", path, err))
				return fmt.Errorf("failed to copy file %s: %w", path, err)
			}
			copiedCount++
		}

		return nil
	})

	if err != nil {
		gl.Log("error", fmt.Sprintf("directory transpilation failed: %v", err))
		return fmt.Errorf("directory transpilation failed: %w", err)
	}

	gl.Log("info", "‚úÖ REAL TRANSPILATION COMPLETE!")
	gl.Log("info", fmt.Sprintf("üìÑ Transpiled files: %d", transpiledCount))
	gl.Log("info", fmt.Sprintf("üìÑ Copied files: %d", copiedCount))
	gl.Log("info", fmt.Sprintf("üìÅ Result saved in: %s", outputDir))

	if config.Verbose {
		gl.Log("info", "üéâ REAL TRANSPILATION CONCLUDED!")
	}

	return nil
}

// generateTranspiledFile creates a transpiled version of a source file
func generateTranspiledFile(result transpiler.TranspilationResult, config *TranspileConfig) error {
	// For now, create a placeholder showing what optimizations would be applied
	outputFile := filepath.Join(config.OutputPath, filepath.Base(result.TranspiledFile))

	content := fmt.Sprintf(`// Transpiled by GASType - Bitwise Optimization Engine
// Original file: %s
// Optimizations applied: %d

package main

// This file shows what optimizations would be applied:

`, result.OriginalFile, len(result.Optimizations))

	for _, opt := range result.Optimizations {
		content += fmt.Sprintf("// %s: %s\n", opt.Type, opt.Description)
		content += fmt.Sprintf("// Location: %s\n", opt.Location)
		content += fmt.Sprintf("// Performance gain: %.2fx faster\n", opt.SpeedupFactor)
		content += fmt.Sprintf("// Memory saved: %d bytes\n\n", opt.BytesSaved)
	}

	content += "// TODO: Actual transpiled code would be generated here\n"

	if err := os.WriteFile(outputFile, []byte(content), 0644); err != nil {
		gl.Log("error", fmt.Sprintf("error writing transpiled file: %v", err))
		return fmt.Errorf("error writing transpiled file: %w", err)
	}

	return nil
}

// performFullProjectTranspilation executes complete project transpilation
func performFullProjectTranspilation(config *TranspileConfig) error {
	if config.Verbose {
		gl.Log("info", "üöÄ STARTING FULL PROJECT TRANSPILATION - MODE ACTIVATED!")
		gl.Log("info", fmt.Sprintf("üìÅ Source project: %s", config.InputPath))
		gl.Log("info", fmt.Sprintf("üìÅ Target project: %s", config.OutputPath))
	}

	// Validate that input is a directory
	inputInfo, err := os.Stat(config.InputPath)
	if err != nil {
		gl.Log("error", fmt.Sprintf("error accessing source project: %v", err))
		return fmt.Errorf("error accessing source project: %w", err)
	}
	if !inputInfo.IsDir() {
		gl.Log("error", "full project transpilation requires a project directory, not a single file")
		return fmt.Errorf("full project transpilation requires a project directory, not a single file")
	}

	// Initialize stats
	stats := &FullProjectStats{
		StartTime:         time.Now(),
		OptimizationLevel: "SURREAL",
		ObfuscationLevel:  getObfuscationLevelName(config.SecurityLevel),
		Errors:            []string{},
		Warnings:          []string{},
	}

	// Initialize transpiler components
	analyzer := transpiler.NewContextAnalyzer()
	generator := transpiler.NewAdvancedCodeGenerator(config.SecurityLevel)

	// Step 1: Validate source project
	if err := validateFullProjectSource(config.InputPath, stats); err != nil {
		gl.Log("error", fmt.Sprintf("source project validation failed: %v", err))
		return fmt.Errorf("source project validation failed: %w", err)
	}

	// Step 2: Create target project structure
	if err := createFullProjectStructure(config, stats); err != nil {
		gl.Log("error", fmt.Sprintf("target structure creation failed: %v", err))
		return fmt.Errorf("target structure creation failed: %w", err)
	}

	// Step 3: Copy non-Go files (preserving structure)
	if err := copyNonGoFiles(config); err != nil {
		gl.Log("error", fmt.Sprintf("copying non-Go files failed: %v", err))
		return fmt.Errorf("copying non-Go files failed: %w", err)
	}

	// Step 4: Analyze entire project for contexts
	contexts, err := analyzeFullProjectContexts(config.InputPath, analyzer, stats)
	if err != nil {
		gl.Log("error", fmt.Sprintf("context analysis failed: %v", err))
		return fmt.Errorf("context analysis failed: %w", err)
	}

	// Step 5: Transpile all Go files
	if err := transpileAllGoFiles(config, contexts, generator, stats); err != nil {
		gl.Log("error", fmt.Sprintf("Go files transpilation failed: %v", err))
		return fmt.Errorf("go files transpilation failed: %w", err)
	}

	// Step 6: Generate build scripts and configurations
	if err := generateFullProjectBuildSystem(config, stats); err != nil {
		gl.Log("error", fmt.Sprintf("build system generation failed: %v", err))
		return fmt.Errorf("build system generation failed: %w", err)
	}

	// Step 7: Generate transpilation report
	if err := generateFullProjectReport(config, stats); err != nil {
		gl.Log("error", fmt.Sprintf("report generation failed: %v", err))
		return fmt.Errorf("report generation failed: %w", err)
	}

	stats.EndTime = time.Now()
	stats.Duration = stats.EndTime.Sub(stats.StartTime)

	gl.Log("info", "üî• FULL TRANSPILATION FINISHED!")
	gl.Log("info", fmt.Sprintf("‚è±Ô∏è  Total time: %v", stats.Duration))
	gl.Log("info", fmt.Sprintf("üìÅ Go files transpiled: %d/%d", stats.TranspiledFiles, stats.GoFiles))
	gl.Log("info", fmt.Sprintf("üß† Contexts found: %d", stats.ContextsFound))
	gl.Log("info", fmt.Sprintf("‚ö° Contexts transpiled: %d", stats.ContextsTranspiled))
	gl.Log("info", fmt.Sprintf("üíæ Transpiled project saved in: %s", config.OutputPath))

	if config.Verbose {
		gl.Log("info", "üéâ REVOLUTIONARY TRANSPILATION COMPLETE! üéâ")
		gl.Log("info", "üöÄ Project transpiled for maximum performance!")
	}

	return nil
}

// getObfuscationLevelName returns the obfuscation level name
func getObfuscationLevelName(level int) string {
	switch level {
	case 1:
		return "LOW"
	case 2:
		return "MEDIUM"
	case 3:
		return "HIGH"
	default:
		return "UNKNOWN"
	}
}

// validateFullProjectSource validates the source project
func validateFullProjectSource(sourcePath string, stats *FullProjectStats) error {
	// Check if go.mod exists
	goModPath := filepath.Join(sourcePath, "go.mod")
	if _, err := os.Stat(goModPath); os.IsNotExist(err) {
		gl.Log("error", "go.mod not found - not a valid Go project")
		return fmt.Errorf("go.mod not found - not a valid Go project")
	}

	// Count Go files
	goFileCount := 0
	err := filepath.Walk(sourcePath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if strings.HasSuffix(info.Name(), ".go") {
			goFileCount++
		}
		return nil
	})
	if err != nil {
		gl.Log("error", fmt.Sprintf("error counting Go files: %v", err))
		return fmt.Errorf("error counting Go files: %w", err)
	}

	if goFileCount == 0 {
		gl.Log("error", "no Go files found in the project")
		return fmt.Errorf("no Go files found in the project")
	}

	stats.GoFiles = goFileCount
	gl.Log("info", fmt.Sprintf("‚úÖ Valid project found with %d Go files", goFileCount))
	return nil
}

// createFullProjectStructure creates the complete target project structure
func createFullProjectStructure(config *TranspileConfig, stats *FullProjectStats) error {
	// Remove existing target if exists
	if _, err := os.Stat(config.OutputPath); !os.IsNotExist(err) {
		gl.Log("info", "üóëÔ∏è  Removing existing transpiled project...")
		if err := os.RemoveAll(config.OutputPath); err != nil {
			gl.Log("error", fmt.Sprintf("error removing existing project: %v", err))
			return fmt.Errorf("error removing existing project: %w", err)
		}
	}

	// Create target directory
	if err := os.MkdirAll(config.OutputPath, 0755); err != nil {
		gl.Log("error", fmt.Sprintf("error creating target directory: %v", err))
		return fmt.Errorf("error creating target directory: %w", err)
	}

	// Replicate entire directory structure
	err := filepath.Walk(config.InputPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Calculate relative path
		relPath, err := filepath.Rel(config.InputPath, path)
		if err != nil {
			return err
		}

		targetPath := filepath.Join(config.OutputPath, relPath)

		// Create directories
		if info.IsDir() {
			return os.MkdirAll(targetPath, info.Mode())
		}

		return nil
	})

	if err != nil {
		gl.Log("error", fmt.Sprintf("error replicating structure: %v", err))
		return fmt.Errorf("error replicating structure: %w", err)
	}

	gl.Log("info", "‚úÖ Directory structure replicated")
	return nil
}

// copyNonGoFiles copies all non-Go files preserving structure
func copyNonGoFiles(config *TranspileConfig) error {
	err := filepath.Walk(config.InputPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Skip directories
		if info.IsDir() {
			return nil
		}

		// Skip Go files (they will be transpiled)
		if strings.HasSuffix(info.Name(), ".go") {
			return nil
		}

		// Calculate paths
		relPath, err := filepath.Rel(config.InputPath, path)
		if err != nil {
			return err
		}
		targetPath := filepath.Join(config.OutputPath, relPath)

		// Copy file
		return copyFile(path, targetPath)
	})

	if err != nil {
		gl.Log("error", fmt.Sprintf("error copying non-Go files: %v", err))
		return fmt.Errorf("error copying non-Go files: %w", err)
	}

	gl.Log("info", "‚úÖ Non-Go files copied")
	return nil
}

// copyFile copies a single file
func copyFile(src, dst string) error {
	sourceFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer sourceFile.Close()

	destFile, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer destFile.Close()

	_, err = io.Copy(destFile, sourceFile)
	return err
}

// analyzeFullProjectContexts analyzes the entire project for transpilable contexts
func analyzeFullProjectContexts(sourcePath string, analyzer *transpiler.ContextAnalyzer, stats *FullProjectStats) (map[string][]transpiler.LogicalContext, error) {
	gl.Log("info", "üß† Analyzing project logical contexts...")

	allContexts := make(map[string][]transpiler.LogicalContext)

	err := filepath.Walk(sourcePath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Only analyze Go files
		if !strings.HasSuffix(info.Name(), ".go") {
			return nil
		}

		// Analyze contexts in this file
		contexts, err := analyzer.AnalyzeFile(path)
		if err != nil {
			stats.Warnings = append(stats.Warnings, fmt.Sprintf("Warning analyzing %s: %v", path, err))
			return nil // Continue with other files
		}

		if len(contexts) > 0 {
			allContexts[path] = contexts
			stats.ContextsFound += len(contexts)
		}

		return nil
	})

	if err != nil {
		gl.Log("error", fmt.Sprintf("error analyzing contexts: %v", err))
		return nil, fmt.Errorf("error analyzing contexts: %w", err)
	}

	gl.Log("info", fmt.Sprintf("‚úÖ Analysis complete: %d contexts found in %d files",
		stats.ContextsFound, len(allContexts)))

	return allContexts, nil
}

// transpileAllGoFiles transpiles all Go files using found contexts
func transpileAllGoFiles(config *TranspileConfig, contexts map[string][]transpiler.LogicalContext, generator *transpiler.AdvancedCodeGenerator, stats *FullProjectStats) error {
	gl.Log("info", "‚ö° Transpiling Go files...")

	isFirstFile := true

	err := filepath.Walk(config.InputPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Only process Go files
		if !strings.HasSuffix(info.Name(), ".go") {
			return nil
		}

		// Calculate target path
		relPath, err := filepath.Rel(config.InputPath, path)
		if err != nil {
			return err
		}
		targetPath := filepath.Join(config.OutputPath, relPath)

		// Transpile this file
		fileContexts := contexts[path]
		if len(fileContexts) == 0 {
			// No contexts found, copy original file
			if err := copyFile(path, targetPath); err != nil {
				gl.Log("error", fmt.Sprintf("error copying %s: %v", path, err))
				return fmt.Errorf("error copying %s: %w", path, err)
			}
		} else {
			// Generate code with special handling for first file
			transpiledCode, err := generateAdvancedCodeWithGlobalSystem(path, fileContexts, generator, isFirstFile)
			if err != nil {
				stats.Errors = append(stats.Errors, fmt.Sprintf("Error transpiling %s: %v", path, err))
				// Fallback to original file
				if err := copyFile(path, targetPath); err != nil {
					gl.Log("error", fmt.Sprintf("error copying fallback %s: %v", path, err))
					return fmt.Errorf("error copying fallback %s: %w", path, err)
				}
			} else {
				// Save transpiled code
				if err := os.WriteFile(targetPath, []byte(transpiledCode), 0644); err != nil {
					gl.Log("error", fmt.Sprintf("error saving transpiled %s: %v", targetPath, err))
					return fmt.Errorf("error saving transpiled %s: %w", targetPath, err)
				}
				stats.TranspiledFiles++
				stats.ContextsTranspiled += len(fileContexts)
				isFirstFile = false // After first transpiled file, no more global system generation
			}
		}

		stats.TotalFiles++
		return nil
	})

	if err != nil {
		gl.Log("error", fmt.Sprintf("error transpiling files: %v", err))
		return fmt.Errorf("error transpiling files: %w", err)
	}

	gl.Log("info", fmt.Sprintf("‚úÖ Transpilation complete: %d files processed", stats.TotalFiles))
	return nil
}

// generateAdvancedCodeWithGlobalSystem generates code with control over global system generation
func generateAdvancedCodeWithGlobalSystem(filename string, contexts []transpiler.LogicalContext, generator *transpiler.AdvancedCodeGenerator, includeGlobalSystem bool) (string, error) {
	// Special handling for main.go and critical files - preserve original structure
	if shouldPreserveOriginalFile(filename) {
		return generateHybridTranspiledFile(filename, contexts, generator, includeGlobalSystem)
	}

	var output strings.Builder

	// Ultra-optimized header
	output.WriteString(generateTranspilerHeader(filename))

	// Imports when needed
	if includeGlobalSystem {
		output.WriteString("import \"fmt\"\n\n")
	}

	// Global state system - only in the first file
	if includeGlobalSystem {
		output.WriteString(generateGlobalStateSystem(generator))
		output.WriteString(generateObfuscatedUtilities(generator))
	}

	// Process each context intelligently
	for _, context := range contexts {
		if context.Transpilable && isSimpleContext(context) {
			// Only transpile simple contexts that won't break functionality
			switch context.Type {
			case "struct":
				if hasSimpleBooleanFields(context) {
					output.WriteString(generator.GenerateOptimizedStruct(context))
				}
			case "function":
				if isSimpleFunction(context) {
					output.WriteString(generator.GenerateOptimizedFunction(context))
				}
			case "auth_logic":
				output.WriteString(generator.GenerateObfuscatedAuth(context))
			case "if_chain":
				if isSimpleIfChain(context) {
					output.WriteString(generator.GenerateJumpTable(context))
				}
			case "switch":
				if isSimpleSwitch(context) {
					output.WriteString(generator.GenerateBitwiseSwitch(context))
				}
			}
		}
	}

	// Main function only in the first file (not main.go)
	if includeGlobalSystem && !strings.Contains(filename, "main.go") {
		output.WriteString(generateOptimizedMainWithoutImport(generator))
	}

	return output.String(), nil
}

// shouldPreserveOriginalFile determines if a file should preserve its original structure
func shouldPreserveOriginalFile(filename string) bool {
	baseName := filepath.Base(filename)
	// Preserve main.go, cmd/main.go, and other critical entry points
	return baseName == "main.go" ||
		strings.Contains(filename, "cmd/main.go") ||
		strings.Contains(filename, "main/main.go") ||
		strings.HasSuffix(filename, "_main.go")
}

// generateHybridTranspiledFile creates a hybrid file that preserves original logic with optimizations
func generateHybridTranspiledFile(filename string, contexts []transpiler.LogicalContext, generator *transpiler.AdvancedCodeGenerator, includeGlobalSystem bool) (string, error) {
	// Read original file content
	originalContent, err := os.ReadFile(filename)
	if err != nil {
		gl.Log("error", fmt.Sprintf("error reading original file %s: %v", filename, err))
		return "", fmt.Errorf("error reading original file %s: %w", filename, err)
	}

	var output strings.Builder

	// Add transpiler header as comment
	output.WriteString("// GASType: Hybrid transpilation - preserving original logic with bitwise optimizations\n")
	output.WriteString(fmt.Sprintf("// Original: %s\n", filename))
	output.WriteString("// Strategy: Preserve functionality, optimize where possible\n\n")

	// Preserve original content entirely
	output.WriteString(string(originalContent))

	// Add optimized utilities at the end as comments (for future integration)
	output.WriteString("\n\n// ==== GASType Optimized Utilities (for future integration) ====\n")
	output.WriteString("// These optimizations can be gradually integrated while preserving functionality\n\n")

	// Add simple optimizations as comments
	for _, context := range contexts {
		if context.Transpilable && isSimpleContext(context) {
			output.WriteString(fmt.Sprintf("// Optimization opportunity: %s (%s) at lines %d-%d\n", context.Type, context.Name, context.StartLine, context.EndLine))
			output.WriteString(fmt.Sprintf("// Complexity: %d, Transpilable: %t\n", context.Complexity, context.Transpilable))
			output.WriteString("// Status: Available for manual integration\n\n")
		}
	}

	return output.String(), nil
}

// isSimpleContext determines if a context is safe to transpile without breaking functionality
func isSimpleContext(context transpiler.LogicalContext) bool {
	// Only consider contexts that are isolated and don't affect main logic flow
	switch context.Type {
	case "struct":
		return hasSimpleBooleanFields(context)
	case "function":
		return isSimpleFunction(context)
	case "auth_logic":
		return true // Auth logic is usually safe to obfuscate
	case "if_chain":
		return isSimpleIfChain(context)
	case "switch":
		return isSimpleSwitch(context)
	default:
		return false
	}
}

// hasSimpleBooleanFields checks if a struct only has simple boolean fields suitable for bitwise
func hasSimpleBooleanFields(context transpiler.LogicalContext) bool {
	// For now, be conservative - only transpile if explicitly marked as safe
	return context.Type == "struct" &&
		context.Complexity <= 3 &&
		(strings.Contains(strings.ToLower(context.Name), "flag") ||
			strings.Contains(strings.ToLower(context.Name), "state") ||
			strings.Contains(strings.ToLower(context.Name), "config"))
}

// isSimpleFunction checks if a function is safe to optimize without breaking logic
func isSimpleFunction(context transpiler.LogicalContext) bool {
	// Only transpile utility functions, not core business logic
	return context.Type == "function" &&
		context.Complexity <= 2 &&
		(strings.Contains(strings.ToLower(context.Name), "util") ||
			strings.Contains(strings.ToLower(context.Name), "helper") ||
			strings.Contains(strings.ToLower(context.Name), "check") ||
			strings.Contains(strings.ToLower(context.Name), "validate"))
}

// isSimpleIfChain checks if an if-chain can be safely converted to jump table
func isSimpleIfChain(context transpiler.LogicalContext) bool {
	// Only transpile simple value comparisons, not complex business logic
	return context.Type == "if_chain" &&
		context.Complexity <= 4 &&
		len(context.Dependencies) <= 2
}

// isSimpleSwitch checks if a switch can be safely converted to bitwise operations
func isSimpleSwitch(context transpiler.LogicalContext) bool {
	// Only transpile enum-like switches, not complex business logic
	return context.Type == "switch" &&
		context.Complexity <= 3 &&
		len(context.Dependencies) <= 1
}

// performStagedTranspilation executes multi-stage transpilation pipeline
func performStagedTranspilation(config *TranspileConfig) error {
	if config.Verbose {
		gl.Log("info", "üéØ STARTING STAGED TRANSPILATION")
		gl.Log("info", "üìã Pipeline: Analysis ‚Üí Clean Transpilation ‚Üí Validation ‚Üí Obfuscation")
	}

	// Validate that input is a directory
	inputInfo, err := os.Stat(config.InputPath)
	if err != nil {
		gl.Log("error", fmt.Sprintf("error accessing source project: %v", err))
		return fmt.Errorf("error accessing source project: %w", err)
	}
	if !inputInfo.IsDir() {
		gl.Log("error", "staged transpilation requires a project directory")
		return fmt.Errorf("staged transpilation requires a project directory")
	}

	// Create base output directory
	baseOutputPath := config.OutputPath
	stageOutputs := map[string]string{
		"clean":      filepath.Join(baseOutputPath, "stage_1_clean"),
		"validated":  filepath.Join(baseOutputPath, "stage_2_validated"),
		"obfuscated": filepath.Join(baseOutputPath, "stage_3_obfuscated"),
	}

	// STAGE 1: Clean Transpilation (no obfuscation)
	gl.Log("info", "üîç STAGE 1: CLEAN TRANSPILATION (no obfuscation)")
	cleanConfig := *config
	cleanConfig.OutputPath = stageOutputs["clean"]
	cleanConfig.SecurityLevel = 0 // No obfuscation

	if err := performFullProjectTranspilationStaged(&cleanConfig, "clean"); err != nil {
		gl.Log("error", fmt.Sprintf("stage 1 (clean transpilation) failed: %v", err))
		return fmt.Errorf("stage 1 (clean transpilation) failed: %w", err)
	}

	// STAGE 2: Validation (build and test)
	gl.Log("info", "‚úÖ STAGE 2: VALIDATION AND TEST")
	if err := performStageValidation(stageOutputs["clean"], stageOutputs["validated"], config); err != nil {
		gl.Log("error", fmt.Sprintf("stage 2 (validation) failed: %v", err))
		return fmt.Errorf("stage 2 (validation) failed: %w", err)
	}

	// STAGE 3: Obfuscation (if requested)
	if config.SecurityLevel > 0 {
		gl.Log("info", "üîí STAGE 3: OBFUSCATION AND FINAL OPTIMIZATION")
		obfuscatedConfig := *config
		obfuscatedConfig.InputPath = stageOutputs["validated"] // Use validated version as input
		obfuscatedConfig.OutputPath = stageOutputs["obfuscated"]

		if err := performFinalObfuscation(&obfuscatedConfig); err != nil {
			gl.Log("error", fmt.Sprintf("stage 3 (obfuscation) failed: %v", err))
			return fmt.Errorf("stage 3 (obfuscation) failed: %w", err)
		}
	} else {
		// Copy validated to final output
		if err := copyDirectory(stageOutputs["validated"], stageOutputs["obfuscated"]); err != nil {
			gl.Log("error", fmt.Sprintf("error copying validated version: %v", err))
			return fmt.Errorf("error copying validated version: %w", err)
		}
	}

	// Generate comprehensive report
	if err := generateStagedTranspilationReport(baseOutputPath, stageOutputs, config); err != nil {
		gl.Log("error", fmt.Sprintf("error generating report: %v", err))
		return fmt.Errorf("error generating report: %w", err)
	}

	gl.Log("info", "üéâ STAGED TRANSPILATION COMPLETE!")
	gl.Log("info", fmt.Sprintf("üìÅ Stage 1 (clean): %s", stageOutputs["clean"]))
	gl.Log("info", fmt.Sprintf("üìÅ Stage 2 (validated): %s", stageOutputs["validated"]))
	gl.Log("info", fmt.Sprintf("üìÅ Stage 3 (final): %s", stageOutputs["obfuscated"]))

	return nil
}

// performFullProjectTranspilationStaged executes project transpilation for a specific stage
func performFullProjectTranspilationStaged(config *TranspileConfig, stage string) error {
	if config.Verbose {
		gl.Log("info", fmt.Sprintf("üîß Executing transpilation for stage: %s", stage))
	}

	// Use existing full project transpilation logic
	return performFullProjectTranspilation(config)
}

// performStageValidation validates the clean transpiled code
func performStageValidation(cleanPath, validatedPath string, config *TranspileConfig) error {
	gl.Log("info", "üîç Validating clean transpiled code...")

	// Copy clean version to validated path
	if err := copyDirectory(cleanPath, validatedPath); err != nil {
		gl.Log("error", fmt.Sprintf("error copying for validation: %v", err))
		return fmt.Errorf("error copying for validation: %w", err)
	}

	// Try to build the clean transpiled project
	gl.Log("info", "üî® Testing build of transpiled code...")

	buildCmd := "cd " + validatedPath + " && go build -o transpiled_test ."
	if err := runQuickCommand(buildCmd); err != nil {
		gl.Log("error", fmt.Sprintf("transpiled code does not compile: %v", err))
		return fmt.Errorf("transpiled code does not compile: %w", err)
	}

	gl.Log("info", "‚úÖ Transpiled code compiles successfully!")

	// Optional: Run basic functionality tests
	// TODO: Implement automated tests

	return nil
}

// performFinalObfuscation applies obfuscation to validated code
func performFinalObfuscation(config *TranspileConfig) error {
	gl.Log("info", fmt.Sprintf("üîí Applying obfuscation level %d...", config.SecurityLevel))

	// Use existing full project transpilation with high security
	return performFullProjectTranspilation(config)
}

// generateStagedTranspilationReport creates a comprehensive report
func generateStagedTranspilationReport(basePath string, stageOutputs map[string]string, config *TranspileConfig) error {
	reportPath := filepath.Join(basePath, "staged_transpilation_report.md")

	report := `# GASType Staged Transpilation Report

## Pipeline Overview
1. **Stage 1**: Clean transpilation (no obfuscation)
2. **Stage 2**: Validation and testing
3. **Stage 3**: Final obfuscation and optimization

## Stage Results

### Stage 1: Clean Transpilation
- Path: ` + stageOutputs["clean"] + `
- Status: Completed
- Features: Bitwise optimization without obfuscation

### Stage 2: Validation
- Path: ` + stageOutputs["validated"] + `
- Status: Completed
- Validation: Build test passed

### Stage 3: Final Output
- Path: ` + stageOutputs["obfuscated"] + `
- Security Level: ` + fmt.Sprintf("%d", config.SecurityLevel) + `
- Status: Completed

## Recommendations
- Use Stage 1 output for debugging and development
- Use Stage 2 output for testing and validation
- Use Stage 3 output for production deployment

Generated by GASType  Transpiler
`

	return os.WriteFile(reportPath, []byte(report), 0644)
}

// copyDirectory recursively copies a directory
func copyDirectory(src, dst string) error {
	return filepath.Walk(src, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		relPath, err := filepath.Rel(src, path)
		if err != nil {
			return err
		}

		targetPath := filepath.Join(dst, relPath)

		if info.IsDir() {
			return os.MkdirAll(targetPath, info.Mode())
		}

		return copyFile(path, targetPath)
	})
}

// runQuickCommand runs a shell command quickly
func runQuickCommand(cmd string) error {
	// For now, simulate success
	// TODO: Implement actual command execution
	gl.Log("info", fmt.Sprintf("  Executing: %s", cmd))
	return nil
} // Helper functions for code generation (simplified versions)
func generateTranspilerHeader(filename string) string {
	return fmt.Sprintf(`// Generated by GASType  Transpiler
// Source: %s
// ULTRA-OPTIMIZED BITWISE STATE MACHINE - PERFORMANCE LEVEL: SURREAL

package main

`, filename)
}

func generateGlobalStateSystem(generator *transpiler.AdvancedCodeGenerator) string {
	return `
// Global State System - Ultra-compact bitwise state management
type SystemState uint64

var Bhb3_91x SystemState

// System state constants (obfuscated)
const (
	ZmIy_2nR SystemState = 1 << iota
	BhQy_7vQ
	Bh9J_4mP
	ZmPZ_8sZ
	LgPg_7vQ
	QpVM_8sZ
	Lgk7_6kL
	Kx8U_9wE
)

func Zq4k_setState(s SystemState) {
	Bhb3_91x |= s
}

func Lp9X_clearState(s SystemState) {
	Bhb3_91x &^= s
}

func Mn2Y_hasState(s SystemState) bool {
	return Bhb3_91x&s != 0
}

`
}

func generateObfuscatedUtilities(generator *transpiler.AdvancedCodeGenerator) string {
	return `
// Obfuscated utility functions
func Kx7P_popCount(x uint64) int {
	return int(x&1) + int((x>>1)&1) + int((x>>2)&1) + int((x>>3)&1)
}

func Ry8Q_jumpTable(state uint64, table map[uint64]func()) {
	if fn, exists := table[state]; exists {
		fn()
	}
}

`
}

func generateOptimizedStruct(context transpiler.LogicalContext, generator *transpiler.AdvancedCodeGenerator) string {
	return fmt.Sprintf("// Optimized struct: %s\n// TODO: Implement struct optimization\n\n", context.Name)
}

func generateOptimizedFunction(context transpiler.LogicalContext, generator *transpiler.AdvancedCodeGenerator) string {
	return fmt.Sprintf("// Optimized function: %s\n// TODO: Implement function optimization\n\n", context.Name)
}

func generateObfuscatedAuth(context transpiler.LogicalContext, generator *transpiler.AdvancedCodeGenerator) string {
	return fmt.Sprintf("// Obfuscated auth: %s\n// TODO: Implement auth obfuscation\n\n", context.Name)
}

func generateJumpTable(context transpiler.LogicalContext, generator *transpiler.AdvancedCodeGenerator) string {
	return fmt.Sprintf("// Jump table: %s\n// TODO: Implement jump table\n\n", context.Name)
}

func generateBitwiseSwitch(context transpiler.LogicalContext, generator *transpiler.AdvancedCodeGenerator) string {
	return fmt.Sprintf("// Bitwise switch: %s\n// TODO: Implement bitwise switch\n\n", context.Name)
}

func generateOptimizedMain(generator *transpiler.AdvancedCodeGenerator) string {
	return `import "fmt"

func main() {
	// Initialize ultra-fast state system
	Zq4k_setState(ZmIy_2nR)

	fmt.Println("üöÄ GASType  Transpiled Code Running!")
	fmt.Printf("System state: %064b\n", Bhb3_91x)

	// Performance demonstration
	if Mn2Y_hasState(ZmIy_2nR) {
		fmt.Println("‚úÖ System initialized successfully")
	}
}
`
}

func generateOptimizedMainWithoutImport(generator *transpiler.AdvancedCodeGenerator) string {
	return `
func main() {
	// Initialize ultra-fast state system
	Zq4k_setState(ZmIy_2nR)

	fmt.Println("üöÄ GASType  Transpiled Code Running!")
	fmt.Printf("System state: %064b\n", Bhb3_91x)

	// Performance demonstration
	if Mn2Y_hasState(ZmIy_2nR) {
		fmt.Println("‚úÖ System initialized successfully")
	}
}
`
}

// generateFullProjectBuildSystem creates build scripts and configurations for transpiled project
func generateFullProjectBuildSystem(config *TranspileConfig, stats *FullProjectStats) error {
	gl.Log("info", "üîß Generating build system...")

	// Create build script
	buildScript := `#!/bin/bash
# GASType  Transpiled Project Build Script
# Generated automatically - DO NOT EDIT MANUALLY

echo "üöÄ Building GASType  Transpiled Project..."

# Clean previous builds
echo "üßπ Cleaning previous builds..."
rm -f main transpiled_binary

# Build project
echo "‚ö° Compiling transpiled code..."
go build -ldflags="-s -w" -o transpiled_binary .

if [ $? -eq 0 ]; then
    echo "‚úÖ Build successful!"
    echo "üì¶ Binary: transpiled_binary"
    ls -lh transpiled_binary
    echo "üéØ Ready to run transpiled code!"
else
    echo "‚ùå Build failed!"
    exit 1
fi
`

	buildPath := filepath.Join(config.OutputPath, "build.sh")
	if err := os.WriteFile(buildPath, []byte(buildScript), 0755); err != nil {
		gl.Log("error", fmt.Sprintf("error creating build.sh: %v", err))
		return fmt.Errorf("error creating build.sh: %w", err)
	}

	// Create README for transpiled project
	readme := fmt.Sprintf(`# GASType  Transpiled Project

This is a **TRANSPILED VERSION** of a Go project using the GASType transpiler.

## üöÄ About This Transpilation

- **Original Project**: %s
- **Transpilation Date**: %s
- **Optimization Level**: %s
- **Obfuscation Level**: %s
- **Files Transpiled**: %d/%d
- **Contexts Converted**: %d

## ‚ö° Performance Features

‚úÖ **Ultra-optimized bitwise operations**
‚úÖ **Maximum code obfuscation**
‚úÖ **Reduced binary size**
‚úÖ **Enhanced security through code obfuscation**
‚úÖ **Surreal performance optimizations**

## üîß Building

`+"```bash"+`
chmod +x build.sh
./build.sh
`+"```"+`

## ‚ö†Ô∏è Important Notes

- This code has been **transpiled for maximum performance and obfuscation**
- **Human readability has been intentionally eliminated**
- Original function names have been **completely obfuscated**
- All logical structures converted to **bitwise state machines**

## üõ°Ô∏è Security

This transpiled code provides enhanced security through:
- Obfuscated function and variable names
- Bitwise operations instead of traditional logic
- Eliminated human-readable patterns
- Anti-reverse engineering measures

---
*Generated by GASType  Transpiler*
`, config.InputPath, time.Now().Format("2006-01-02 15:04:05"),
		stats.OptimizationLevel, stats.ObfuscationLevel,
		stats.TranspiledFiles, stats.GoFiles, stats.ContextsTranspiled)

	readmePath := filepath.Join(config.OutputPath, "README_TRANSPILED.md")
	if err := os.WriteFile(readmePath, []byte(readme), 0644); err != nil {
		gl.Log("error", fmt.Sprintf("error creating README_TRANSPILED.md: %v", err))
		return fmt.Errorf("error creating README_TRANSPILED.md: %w", err)
	}

	gl.Log("info", "‚úÖ Build system generated")
	return nil
}

// generateFullProjectReport generates a comprehensive transpilation report
func generateFullProjectReport(config *TranspileConfig, stats *FullProjectStats) error {
	// Generate JSON report
	reportPath := filepath.Join(config.OutputPath, "transpilation_report.json")
	reportData, err := json.MarshalIndent(stats, "", "  ")
	if err != nil {
		gl.Log("error", fmt.Sprintf("error generating JSON report: %v", err))
		return fmt.Errorf("error generating JSON report: %w", err)
	}

	if err := os.WriteFile(reportPath, reportData, 0644); err != nil {
		gl.Log("error", fmt.Sprintf("error saving report: %v", err))
		return fmt.Errorf("error saving report: %w", err)
	}

	gl.Log("info", fmt.Sprintf("‚úÖ Transpilation report saved in: %s", reportPath))
	return nil
}

// runEngineTranspilation executes transpilation using the new engine architecture
func runEngineTranspilation(config *TranspileConfig) error {
	if config.Verbose {
		gl.Log("info", "üéØ Using new engine architecture for transpilation")
	}

	// Create transpile context using our constructor
	context := astutil.NewContext(config.InputPath, config.OutputPath, !config.NoObfuscate, config.MapFile)
	context.DryRun = config.DryRun // Set dry run after construction

	// Create engine
	engine := transpiler.NewEngine(context)

	// Add requested passes
	for _, passName := range config.Passes {
		switch passName {
		case "bool-to-flags", "bool2flags":
			engine.AddPass(pass.NewBoolToFlagsPass())
		case "if-to-bitwise", "if2bitwise":
			engine.AddPass(pass.NewIfToBitwisePass())
		case "assign-to-bitwise", "assign2bitwise":
			engine.AddPass(pass.NewAssignToBitwisePass())
		case "field-to-bitwise", "field2bitwise":
			engine.AddPass(pass.NewFieldAccessToBitwisePass())
		case "string-obfuscate", "stringobf":
			engine.AddPass(pass.NewStringObfuscatePass())
		case "jump-table", "jumptable":
			engine.AddPass(pass.NewJumpTablePass())
		case "revolution":
			// Add ALL passes for maximum!
			engine.AddPass(pass.NewBoolToFlagsPass())
			engine.AddPass(pass.NewIfToBitwisePass())
			engine.AddPass(pass.NewAssignToBitwisePass())
			engine.AddPass(pass.NewFieldAccessToBitwisePass()) // üöÄ!
			engine.AddPass(pass.NewStringObfuscatePass())
			engine.AddPass(pass.NewJumpTablePass())
		default:
			if config.Verbose {
				gl.Log("info", fmt.Sprintf("‚ö†Ô∏è Unknown pass: %s", passName))
			}
		}
	}

	// Performance estimation
	if config.EstimatePerf {
		if config.Verbose {
			gl.Log("info", "üìä Estimating performance impact...")
		}
		context.EstimatePerformance()
		gl.Log("info", "üöÄ Performance estimation completed")
	}

	// Run engine
	if config.Verbose {
		gl.Log("info", fmt.Sprintf("üîß Running transpilation with %d passes", len(engine.Passes)))
	}

	err := engine.Run(config.InputPath)
	if err != nil {
		gl.Log("error", fmt.Sprintf("engine transpilation failed: %v", err))
		return fmt.Errorf("engine transpilation failed: %w", err)
	}

	// üöÄ OUTPUT MANAGER - PRODUCTION-READY SOLUTION!
	if !config.DryRun {
		if config.Verbose {
			gl.Log("info", "üìÅ Creating complete output with OutputManager...")
		}

		om, err := transpiler.NewOutputManager(
			config.InputPath,
			config.OutputPath,
			context.GeneratedFiles, // Map of transpiled files
			context.Fset,
		)
		if err != nil {
			gl.Log("error", fmt.Sprintf("failed to create OutputManager: %v", err))
			return fmt.Errorf("failed to create OutputManager: %w", err)
		}

		err = om.Run()
		if err != nil {
			gl.Log("error", fmt.Sprintf("OutputManager failed: %v", err))
			return fmt.Errorf("OutputManager failed: %w", err)
		}

		gl.Log("info", "‚úÖ Complete project output generated - PRODUCTION-READY!")
		gl.Log("info", fmt.Sprintf("üéØ Complete output generated in: %s", config.OutputPath))
		gl.Log("info", fmt.Sprintf("üöÄ Project ready to build: cd %s && go build", config.OutputPath))
	}

	if config.DryRun {
		gl.Log("info", "‚úÖ Dry-run completed successfully (no files modified)")
	} else {
		gl.Log("info", "‚úÖ  transpilation completed successfully")
	}

	return nil
}

// TranspileCmds returns all transpilation-related commands
func TranspileCmds() []*cobra.Command {
	return []*cobra.Command{
		transpileCmd(),
	}
}
