// Package transpiler implements optimized bitwise code generation
package transpiler

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"strings"

	gl "github.com/rafa-mori/gastype/internal/module/logger"
)

// BitwiseCodeGenerator generates optimized Go code with bitwise operations
type BitwiseCodeGenerator struct {
	fset *token.FileSet
}

// NewBitwiseCodeGenerator creates a new bitwise code generator
func NewBitwiseCodeGenerator() *BitwiseCodeGenerator {
	return &BitwiseCodeGenerator{
		fset: token.NewFileSet(),
	}
}

// GenerateBitwiseCode generates optimized bitwise code from a traditional Go file
func (bcg *BitwiseCodeGenerator) GenerateBitwiseCode(filename string) (string, error) {
	node, err := parser.ParseFile(bcg.fset, filename, nil, parser.ParseComments)
	if err != nil {
		gl.Log("error", fmt.Sprintf("error parsing file: %v", err))
		return "", fmt.Errorf("error parsing file: %w", err)
	}

	var output strings.Builder

	// Generated file header
	output.WriteString("// Generated by GASType Bitwise Transpiler\n")
	output.WriteString("// Original file: " + filename + "\n")
	output.WriteString("// ULTRA-OPTIMIZED BITWISE CODE - DO NOT EDIT MANUALLY!\n\n")

	output.WriteString("package main\n\n")
	output.WriteString("import (\n\t\"fmt\"\n)\n\n")

	// Generate bitwise flag definitions
	output.WriteString(bcg.generateBitwiseDefinitions(node))

	// Generate bitwise utility functions
	output.WriteString(bcg.generateBitwiseUtilities())

	// Generate main transpiled code
	output.WriteString(bcg.generateTranspiledMain(node))

	return output.String(), nil
}

// generateBitwiseDefinitions generates bitwise flag definitions for structs
func (bcg *BitwiseCodeGenerator) generateBitwiseDefinitions(node *ast.File) string {
	var output strings.Builder

	ast.Inspect(node, func(n ast.Node) bool {
		if typeSpec, ok := n.(*ast.TypeSpec); ok {
			if structType, ok := typeSpec.Type.(*ast.StructType); ok {
				bitwiseCode := bcg.convertStructToBitwise(typeSpec.Name.Name, structType)
				if bitwiseCode != "" {
					output.WriteString(bitwiseCode)
					output.WriteString("\n")
				}
			}
		}
		return true
	})

	return output.String()
}

// convertStructToBitwise converte uma struct com campos bool para sistema de flags bitwise
func (bcg *BitwiseCodeGenerator) convertStructToBitwise(structName string, structType *ast.StructType) string {
	var boolFields []string
	var otherFields []string

	// Separar campos bool dos demais
	for _, field := range structType.Fields.List {
		if ident, ok := field.Type.(*ast.Ident); ok && ident.Name == "bool" {
			for _, name := range field.Names {
				boolFields = append(boolFields, name.Name)
			}
		} else {
			// Campos n√£o-bool mantidos como est√£o
			for _, name := range field.Names {
				fieldType := ""
				if ident, ok := field.Type.(*ast.Ident); ok {
					fieldType = ident.Name
				}
				otherFields = append(otherFields, fmt.Sprintf("\t%s %s", name.Name, fieldType))
			}
		}
	}

	if len(boolFields) == 0 {
		return ""
	}

	var output strings.Builder

	// Generate flag type
	flagTypeName := structName + "Flags"
	output.WriteString(fmt.Sprintf("// %s represents bitwise flags for %s\n", flagTypeName, structName))
	output.WriteString(fmt.Sprintf("type %s uint64\n\n", flagTypeName))

	// Generate flag constants
	output.WriteString(fmt.Sprintf("// %s flag constants\n", structName))
	output.WriteString("const (\n")
	for i, field := range boolFields {
		if i == 0 {
			output.WriteString(fmt.Sprintf("\tFlag%s_%s %s = 1 << iota\n", structName, field, flagTypeName))
		} else {
			output.WriteString(fmt.Sprintf("\tFlag%s_%s\n", structName, field))
		}
	}
	output.WriteString(")\n\n")

	// Generate optimized bitwise struct
	output.WriteString(fmt.Sprintf("// %sBitwise is the bitwise-optimized version of %s\n", structName, structName))
	output.WriteString(fmt.Sprintf("type %sBitwise struct {\n", structName))
	output.WriteString(fmt.Sprintf("\tFlags %s `json:\"flags\"`\n", flagTypeName))

	// Add non-bool fields if they exist
	for _, field := range otherFields {
		output.WriteString(field + "\n")
	}

	output.WriteString("}\n\n")

	// Generate utility methods
	output.WriteString(bcg.generateFlagMethods(structName, flagTypeName, boolFields))

	return output.String()
}

// generateFlagMethods generates methods for flag manipulation
func (bcg *BitwiseCodeGenerator) generateFlagMethods(structName, flagTypeName string, fields []string) string {
	var output strings.Builder
	bitwiseStructName := structName + "Bitwise"

	// M√©todo para setar flag
	output.WriteString(fmt.Sprintf("// Set%sFlag sets a specific flag\n", structName))
	output.WriteString(fmt.Sprintf("func (c *%s) Set%sFlag(flag %s) {\n", bitwiseStructName, structName, flagTypeName))
	output.WriteString("\tc.Flags |= flag\n")
	output.WriteString("}\n\n")

	// M√©todo para limpar flag
	output.WriteString(fmt.Sprintf("// Clear%sFlag clears a specific flag\n", structName))
	output.WriteString(fmt.Sprintf("func (c *%s) Clear%sFlag(flag %s) {\n", bitwiseStructName, structName, flagTypeName))
	output.WriteString("\tc.Flags &^= flag\n")
	output.WriteString("}\n\n")

	// M√©todo para verificar flag
	output.WriteString(fmt.Sprintf("// Has%sFlag checks if a specific flag is set\n", structName))
	output.WriteString(fmt.Sprintf("func (c *%s) Has%sFlag(flag %s) bool {\n", bitwiseStructName, structName, flagTypeName))
	output.WriteString("\treturn c.Flags&flag != 0\n")
	output.WriteString("}\n\n")

	// Generate specific methods for each bool field
	for _, field := range fields {
		// Getter
		output.WriteString(fmt.Sprintf("// %s returns the state of %s flag\n", field, field))
		output.WriteString(fmt.Sprintf("func (c *%s) %s() bool {\n", bitwiseStructName, field))
		output.WriteString(fmt.Sprintf("\treturn c.Has%sFlag(Flag%s_%s)\n", structName, structName, field))
		output.WriteString("}\n\n")

		// Setter
		output.WriteString(fmt.Sprintf("// Set%s sets the %s flag\n", field, field))
		output.WriteString(fmt.Sprintf("func (c *%s) Set%s(enabled bool) {\n", bitwiseStructName, field))
		output.WriteString("\tif enabled {\n")
		output.WriteString(fmt.Sprintf("\t\tc.Set%sFlag(Flag%s_%s)\n", structName, structName, field))
		output.WriteString("\t} else {\n")
		output.WriteString(fmt.Sprintf("\t\tc.Clear%sFlag(Flag%s_%s)\n", structName, structName, field))
		output.WriteString("\t}\n")
		output.WriteString("}\n\n")
	}

	return output.String()
}

// generateBitwiseUtilities generates utility functions for bitwise operations
func (bcg *BitwiseCodeGenerator) generateBitwiseUtilities() string {
	return `// Bitwise utility functions for performance optimization

// PopCount counts the number of set bits (performance critical)
func PopCount(x uint64) int {
	count := 0
	for x != 0 {
		count++
		x &= x - 1 // Clear lowest set bit
	}
	return count
}

// HasAnyFlags checks if any of the specified flags are set (ultra-fast)
func HasAnyFlags(value, mask uint64) bool {
	return value&mask != 0
}

// HasAllFlags checks if all specified flags are set (ultra-fast)
func HasAllFlags(value, mask uint64) bool {
	return value&mask == mask
}

// ToggleFlags toggles specified flags (XOR operation)
func ToggleFlags(value, mask uint64) uint64 {
	return value ^ mask
}

`
}

// generateTranspiledMain generates the transpiled main function
func (bcg *BitwiseCodeGenerator) generateTranspiledMain(node *ast.File) string {
	var output strings.Builder

	output.WriteString("// Transpiled main function with bitwise optimizations\n")
	output.WriteString("func main() {\n")
	output.WriteString("\tfmt.Println(\"üöÄ GASType Bitwise-Optimized Code Running!\")\n\n")

	// Exemplo de uso do c√≥digo bitwise
	output.WriteString("\t// Create bitwise-optimized Discord config\n")
	output.WriteString("\tconfig := &DiscordConfigBitwise{}\n")
	output.WriteString("\tconfig.SetEnableBot(true)\n")
	output.WriteString("\tconfig.SetEnableCommands(true)\n")
	output.WriteString("\tconfig.SetEnableLogging(true)\n\n")

	output.WriteString("\t// Ultra-fast bitwise logic (replaces slow if/else chains)\n")
	output.WriteString("\tbotAndCommands := FlagDiscordConfig_EnableBot | FlagDiscordConfig_EnableCommands\n")
	output.WriteString("\tif HasAllFlags(uint64(config.Flags), uint64(botAndCommands)) {\n")
	output.WriteString("\t\tfmt.Println(\"‚úÖ Bot with commands enabled (BITWISE OPTIMIZED!)\")\n")
	output.WriteString("\t}\n\n")

	output.WriteString("\tbotAndLogging := FlagDiscordConfig_EnableBot | FlagDiscordConfig_EnableLogging\n")
	output.WriteString("\tif HasAllFlags(uint64(config.Flags), uint64(botAndLogging)) {\n")
	output.WriteString("\t\tfmt.Println(\"‚úÖ Bot with logging enabled (BITWISE OPTIMIZED!)\")\n")
	output.WriteString("\t}\n\n")

	// Performance demonstration
	output.WriteString("\t// Performance demonstration\n")
	output.WriteString("\tfmt.Printf(\"üî• Active flags count: %d\\n\", PopCount(uint64(config.Flags)))\n")
	output.WriteString("\tfmt.Printf(\"‚ö° Config flags: %064b\\n\", config.Flags)\n")

	output.WriteString("}\n")

	return output.String()
}
