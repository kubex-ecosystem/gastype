# LookAtni Code - Gerado automaticamente
# Data: 2025-08-14T01:01:34.824Z
# Fonte: ./
# Total de arquivos: 28

/// actions/action.go ///
package actions

import (
	i "github.com/rafa-mori/gastype/interfaces"
)

// Action Common struct for all actions
type Action struct {
	ID        string
	Type      string
	Status    string
	Errors    []error
	Results   map[string]interface{}
	isRunning bool
}

func NewAction(id, actionType string) i.IAction {
	return &Action{
		ID:      id,
		Type:    actionType,
		Status:  "Pending",
		Results: make(map[string]interface{}),
	}
}

func (a *Action) GetID() string                      { return a.ID }
func (a *Action) GetType() string                    { return a.Type }
func (a *Action) GetResults() map[string]interface{} { return a.Results }
func (a *Action) GetStatus() string                  { return a.Status }
func (a *Action) GetErrors() []error                 { return a.Errors }
func (a *Action) IsRunning() bool                    { return a.isRunning }
func (a *Action) CanExecute() bool                   { return !a.isRunning }
func (a *Action) Execute() error {
	a.isRunning = true
	defer func() { a.isRunning = false }()

	// Placeholder for actual execution logic
	return nil
}

/// actions/type_check.go ///
// Package actions implements various actions for type checking in Go projects.
package actions

import (
	"fmt"
	"os"
	"path/filepath"
	"sync"

	"go/ast"
	"go/parser"
	"go/token"

	log "github.com/faelmori/logz"
	types "github.com/rafa-mori/gastype/interfaces"
)

// TypeCheckAction defines a type-checking action
type TypeCheckAction struct {
	Action       // Embedding the base action
	Config       types.IConfig
	ParsedFiles  map[string][]*ast.File
	FileSet      *token.FileSet
	ErrorChannel chan error
}

// NewTypeCheckAction creates a new type-checking action
func NewTypeCheckAction(pkg string, files []*ast.File, cfg types.IConfig) *TypeCheckAction {
	return &TypeCheckAction{
		Action: Action{
			Type:    "TypeCheck",
			Status:  "Pending",
			Results: make(map[string]interface{}),
		},
		Config:       cfg,
		ParsedFiles:  map[string][]*ast.File{pkg: files},
		FileSet:      token.NewFileSet(),
		ErrorChannel: make(chan error, cfg.GetWorkerCount()),
	}
}

// Execute runs the type-checking process
func (tca *TypeCheckAction) Execute() error {
	tca.Status = "Running"
	defer func() { tca.Status = "Completed" }()

	dir := tca.Config.GetDir()
	absDir, err := filepath.Abs(dir)
	if err != nil {
		return fmt.Errorf("invalid directory path: %v", err)
	}

	// Ensure the directory exists
	if _, err := os.Stat(absDir); os.IsNotExist(err) {
		return fmt.Errorf("directory does not exist: %s", absDir)
	}

	// Find all Go files
	files, err := filepath.Glob(filepath.Join(absDir, "*.go"))
	if err != nil {
		return fmt.Errorf("error finding Go files: %v", err)
	}
	if len(files) == 0 {
		return fmt.Errorf("no Go files found in directory: %s", absDir)
	}

	// Parse files in parallel
	var wg sync.WaitGroup
	for _, file := range files {
		wg.Add(1)
		go func(file string) {
			defer wg.Done()
			if parseErr := tca.parseFile(file); parseErr != nil {
				tca.ErrorChannel <- parseErr
			}
		}(file)
	}
	wg.Wait()
	close(tca.ErrorChannel)

	// Collect errors
	for err := range tca.ErrorChannel {
		log.Error(fmt.Sprintf("Error during type checking: %v", err), nil)
		tca.Errors = append(tca.Errors, err)
	}

	tca.Status = "Completed"
	return nil
}

// parseFile parses a single Go file
func (tca *TypeCheckAction) parseFile(file string) error {
	src, err := os.ReadFile(file)
	if err != nil {
		return fmt.Errorf("error reading file %s: %v", file, err)
	}

	node, err := parser.ParseFile(tca.FileSet, file, src, parser.AllErrors)
	if err != nil {
		return fmt.Errorf("error parsing %s: %v", file, err)
	}

	// Store parsed file
	tca.ParsedFiles[node.Name.Name] = append(tca.ParsedFiles[node.Name.Name], node)
	return nil
}

/// astutil/config.go ///
package astutil

import (
	"fmt"
	"os"

	t "github.com/rafa-mori/gastype/interfaces"
	"github.com/rafa-mori/gastype/internal/globals"
)

type Config struct {
	dir         string
	workerCount int
	outputFile  string
	enviroment  t.IEnvironment
}

func NewConfig() t.IConfig {
	cfg := &Config{}
	cfg.enviroment = globals.NewEnvironment()
	return cfg
}

func NewConfigWithArgs(dir string, workerCount int, outputFile string) t.IConfig {
	env := globals.NewEnvironment()
	cfg := &Config{
		dir:         dir,
		workerCount: workerCount,
		outputFile:  outputFile,
		enviroment:  env,
	}

	if loadErr := cfg.Load(); loadErr != nil {
		return nil
	}

	return cfg
}

func (c *Config) Load() error {
	if c.dir == "" {
		c.dir = "./"
	}
	if c.workerCount == 0 {
		cpuCount := c.enviroment.CPUCount()
		if cpuCount > 0 {
			if cpuCount >= 4 {
				c.workerCount = 4
			} else {
				c.workerCount = cpuCount
			}
		}
	}
	if c.outputFile == "" {
		homeDir, homeDirErr := os.UserHomeDir()
		if homeDirErr != nil {
			homeDir, homeDirErr = os.UserCacheDir()
			if homeDirErr != nil {
				c.outputFile = "type_check_results.json"
				return nil
			}
		}
		c.outputFile = fmt.Sprintf("%s/tmp/type_check_results.json", homeDir)
	}
	return nil
}
func (c *Config) GetDir() string                  { return c.dir }
func (c *Config) GetWorkerCount() int             { return c.workerCount }
func (c *Config) GetOutputFile() string           { return c.outputFile }
func (c *Config) SetDir(dir string)               { c.dir = dir }
func (c *Config) SetWorkerLimit(workerCount int)  { c.workerCount = workerCount }
func (c *Config) SetOutputFile(outputFile string) { c.outputFile = outputFile }

/// astutil/context.go ///
package astutil

import (
	"encoding/json"
	"fmt"
	"go/ast"
	"go/token"
	"os"
	"strings"
)

type AssignTransformation struct {
	File     string `json:"file"`
	Field    string `json:"field"`
	FlagName string `json:"flag_name"`
	Value    string `json:"value"`
}

// TranspileContext tracks all information about a transpilation operation
type TranspileContext struct {
	*Info

	// General configuration
	Ofuscate  bool   `json:"ofuscate"`   // If true, names and structure will be obfuscated
	MapFile   string `json:"map_file"`   // Path to output .map.json file
	InputFile string `json:"input_file"` // Input file path
	OutputDir string `json:"output_dir"` // Output directory
	DryRun    bool   `json:"dry_run"`    // If true, only analyze without saving files

	// Analysis results
	Structs map[string]*StructInfo `json:"structs"` // Original struct → detailed info
	Flags   map[string][]string    `json:"flags"`   // Struct → list of generated flags

	// 🚀 REVOLUTIONARY FIELDS for OutputManager
	GeneratedFiles map[string]*ast.File `json:"-"` // File path → transpiled AST
	Fset           *token.FileSet       `json:"-"` // Token file set for all files

	// 🔥 PACKAGE-SCOPED CONSTANTS TRACKING
	PackageConstantsAdded map[string]bool `json:"-"` // Package → constants added (prevents duplicates)

	AssignTransformations []AssignTransformation `json:"assign_transformations"` // Track all assign transformations
}

// StructInfo contains detailed information about each detected struct
type StructInfo struct {
	OriginalName    string            `json:"original_name"`   // Original name (e.g., Config)
	NewName         string            `json:"new_name"`        // Final name (e.g., ConfigFlags)
	BoolFields      []string          `json:"bool_fields"`     // Original bool fields
	FlagMapping     map[string]string `json:"flag_mapping"`    // BoolField → FlagName
	Transformations map[string]string `json:"transformations"` // Track applied transformations
}

// NewContext creates a new transpilation context
func NewContext(inputFile, outputDir string, ofuscate bool, mapFile string) *TranspileContext {
	return &TranspileContext{
		Ofuscate:       ofuscate,
		MapFile:        mapFile,
		InputFile:      inputFile,
		OutputDir:      outputDir,
		Structs:        make(map[string]*StructInfo),
		Flags:          make(map[string][]string),
		GeneratedFiles: make(map[string]*ast.File), // 🚀 REVOLUTIONARY: Store transpiled files
		Fset:           token.NewFileSet(),         // 🚀 REVOLUTIONARY: Share FileSet across all operations
	}
}

// AddStruct registers a struct transformation in the context
func (ctx *TranspileContext) AddStruct(packageName, originalName, newName string, boolFields []string) {
	mapping := make(map[string]string)
	for _, f := range boolFields {
		// 🚀 REVOLUTIONARY: Include package name to avoid conflicts
		mapping[f] = fmt.Sprintf("Flag%s_%s_%s", strings.Title(packageName), originalName, strings.Title(f))
	}

	ctx.Structs[originalName] = &StructInfo{
		OriginalName: originalName,
		NewName:      newName,
		BoolFields:   boolFields,
		FlagMapping:  mapping,
	}
	ctx.Flags[newName] = boolFields
}

// AddFlagMapping adds a flag mapping for a specific struct and field (cleaner approach)
func (ctx *TranspileContext) AddFlagMapping(structName, fieldName, flagName string, bitPos int) {
	if ctx.Structs[structName] == nil {
		ctx.Structs[structName] = &StructInfo{
			OriginalName: structName,
			BoolFields:   []string{},
			FlagMapping:  map[string]string{},
		}
	}
	ctx.Structs[structName].FlagMapping[fieldName] = flagName
}

// GetFlagName returns the flag name for a given struct and field
func (ctx *TranspileContext) GetFlagName(packageName, structName, fieldName string) string {
	if structInfo, exists := ctx.Structs[structName]; exists {
		if flagName, exists := structInfo.FlagMapping[fieldName]; exists {
			return flagName
		}
	}
	// 🚀 REVOLUTIONARY: Include package name to avoid conflicts between packages
	return fmt.Sprintf("Flag%s_%s_%s", strings.Title(packageName), structName, strings.Title(fieldName))
}

// IsStructTransformed checks if a struct has been transformed
func (ctx *TranspileContext) IsStructTransformed(structName string) bool {
	_, exists := ctx.Structs[structName]
	return exists
}

// GetTransformedStructName returns the new name for a transformed struct
func (ctx *TranspileContext) GetTransformedStructName(originalName string) string {
	if structInfo, exists := ctx.Structs[originalName]; exists {
		return structInfo.NewName
	}
	return originalName + "Flags" // fallback
}

// IsBoolField checks if a field is a bool field in any transformed struct
func (ctx *TranspileContext) IsBoolField(structName, fieldName string) bool {
	if structInfo, exists := ctx.Structs[structName]; exists {
		for _, boolField := range structInfo.BoolFields {
			if boolField == fieldName {
				return true
			}
		}
	}
	return false
}

// SaveMap saves the context as a JSON map file
func (ctx *TranspileContext) SaveMap() error {
	if ctx.MapFile == "" {
		return nil
	}

	data, err := json.MarshalIndent(ctx, "", "  ")
	if err != nil {
		return err
	}

	return os.WriteFile(ctx.MapFile, data, 0644)
}

// RegisterAssignToBitwise registra uma conversão de atribuição bool para bitwise flag
func (ctx *TranspileContext) RegisterAssignToBitwise(file, field, flagName, value string) {
	ctx.AssignTransformations = append(ctx.AssignTransformations, AssignTransformation{
		File:     file,
		Field:    field,
		FlagName: flagName,
		Value:    value,
	})

	// Log imediato se verbose
	ctx.LogVerbose(nil, "    ⚡ AssignToBitwise: %s → %s (%s = %s)", field, flagName, field, value)
}

// GetAssignTransformations retorna todas as transformações registradas
func (ctx *TranspileContext) GetAssignTransformations() []AssignTransformation {
	return ctx.AssignTransformations
}

// LoadMap loads a context from a JSON map file
func LoadMap(mapFile string) (*TranspileContext, error) {
	data, err := os.ReadFile(mapFile)
	if err != nil {
		return nil, err
	}

	var ctx TranspileContext
	err = json.Unmarshal(data, &ctx)
	if err != nil {
		return nil, err
	}

	return &ctx, nil
}

// EstimatePerformance provides performance estimates for the transpilation
func (ctx *TranspileContext) EstimatePerformance() {
	fmt.Printf("\n📊 Performance Estimation:\n")

	totalStructs := len(ctx.Structs)
	totalBoolFields := 0
	totalFlagsGenerated := 0

	for _, structInfo := range ctx.Structs {
		totalBoolFields += len(structInfo.BoolFields)
		totalFlagsGenerated += len(structInfo.BoolFields)
	}

	if totalStructs == 0 {
		fmt.Printf("  ℹ️  No transformations found - no performance impact\n")
		return
	}

	// Memory usage estimates
	originalMemoryPerStruct := totalBoolFields // each bool = 1 byte typically
	optimizedMemoryPerStruct := 8              // uint64 = 8 bytes

	memoryReduction := float64(originalMemoryPerStruct-optimizedMemoryPerStruct) / float64(originalMemoryPerStruct) * 100
	if memoryReduction < 0 {
		memoryReduction = 0 // In cases where we have few bools, memory might increase slightly
	}

	fmt.Printf("  📈 Structs analyzed: %d\n", totalStructs)
	fmt.Printf("  🔢 Bool fields → Flags: %d → %d constants\n", totalBoolFields, totalFlagsGenerated)
	fmt.Printf("  💾 Memory per struct: %d bytes → 8 bytes\n", originalMemoryPerStruct)

	if memoryReduction > 0 {
		fmt.Printf("  ⚡ Estimated memory reduction: %.1f%%\n", memoryReduction)
	} else {
		fmt.Printf("  ℹ️  Memory usage: minimal change (small struct overhead)\n")
	}

	// Performance benefits
	fmt.Printf("  🚀 Performance benefits:\n")
	fmt.Printf("     • Bitwise operations: ~2-5x faster than bool comparisons\n")
	fmt.Printf("     • Cache efficiency: Better memory locality\n")
	fmt.Printf("     • Atomic operations: Single uint64 vs multiple bools\n")

	// Security benefits
	fmt.Printf("  🔒 Security benefits:\n")
	fmt.Printf("     • Obfuscated logic: Harder to reverse engineer\n")
	fmt.Printf("     • Compact representation: Less surface area\n")
}

// GetFlagForField Retorna o nome da flag de um campo já registrado no contexto
func GetFlagForField(ctx *TranspileContext, structName, fieldName string) (string, bool) {
	if s, ok := ctx.Structs[structName]; ok {
		flag, exists := s.FlagMapping[fieldName]
		return flag, exists
	}
	return "", false
}

// AddFlagMapping Registra um mapeamento de campo -> flag no contexto
func AddFlagMapping(ctx *TranspileContext, structName, fieldName, flagName string, bitIndex int) {
	ctx.AddFlagMapping(structName, fieldName, flagName, 1<<bitIndex)
}

// LogVerbose helper to log transformations (if verbose logging exists in context)
func (ctx *TranspileContext) LogVerbose(fset *token.FileSet, format string, args ...interface{}) {
	// For now, just print - could be enhanced with proper logging
	if len(args) > 0 {
		// Use a simple printf for now
		_ = fset // avoid unused warning
		// fmt.Printf(format+"\n", args...)
	}
}

/// astutil/decision.go ///
package astutil

// DeveConverterBools decide se vale a pena converter essa struct para bitflags
func DeveConverterBools(numBools int) bool {
	// Regra global inicial: só converte se tiver 3 ou mais bools
	return numBools >= 3
}

/// astutil/flags.go ///
// Package astutil fornece funções utilitárias para manipulação de flags
package astutil

// SetFlag ativa um flag específico
func SetFlag(v interface{}, f uint64) {
	switch ptr := v.(type) {
	case *uint8:
		*ptr |= uint8(f)
	case *uint16:
		*ptr |= uint16(f)
	case *uint32:
		*ptr |= uint32(f)
	case *uint64:
		*ptr |= uint64(f)
	}
}

// ClearFlag desativa um flag específico
func ClearFlag(v interface{}, f uint64) {
	switch ptr := v.(type) {
	case *uint8:
		*ptr &^= uint8(f)
	case *uint16:
		*ptr &^= uint16(f)
	case *uint32:
		*ptr &^= uint32(f)
	case *uint64:
		*ptr &^= uint64(f)
	}
}

// ToggleFlag inverte um flag específico
func ToggleFlag(v interface{}, f uint64) {
	switch ptr := v.(type) {
	case *uint8:
		*ptr ^= uint8(f)
	case *uint16:
		*ptr ^= uint16(f)
	case *uint32:
		*ptr ^= uint32(f)
	case *uint64:
		*ptr ^= uint64(f)
	}
}

// HasFlag verifica se um flag específico está ativo
func HasFlag(v interface{}, f uint64) bool {
	switch val := v.(type) {
	case uint8:
		return val&uint8(f) != 0
	case uint16:
		return val&uint16(f) != 0
	case uint32:
		return val&uint32(f) != 0
	case uint64:
		return val&uint64(f) != 0
	}
	return false
}

/// astutil/indents.go ///
package astutil

import "go/ast"

func GetRootIdent(expr ast.Expr) *ast.Ident {
	switch v := expr.(type) {
	case *ast.Ident:
		return v
	case *ast.SelectorExpr:
		return GetRootIdent(v.X)
	case *ast.StarExpr:
		return GetRootIdent(v.X)
	default:
		return nil
	}
}

func IsValidIdent(name string) bool {
	if name == "" {
		return false
	}
	for _, r := range name {
		if !IsValidIdentRune(r) {
			return false
		}
	}
	return true
}

func IsValidIdentRune(r rune) bool {
	return r == '_' || r == '$' || (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9')
}

/// astutil/info.go ///
package astutil

import (
	"go/ast"
	"go/types"
)

type Info struct {
	Types        map[ast.Expr]types.TypeAndValue
	Instances    map[*ast.Ident]types.Object
	Defs         map[*ast.Ident]types.Object
	Uses         map[*ast.Ident]types.Object
	Implicits    map[ast.Node]types.Object
	Selections   map[*ast.SelectorExpr]*types.Selection
	Scopes       map[ast.Node]*types.Scope
	InitOrder    []*types.Initializer
	FileVersions map[*ast.File]string
}

func NewInfo() *Info {
	return &Info{
		Types:        make(map[ast.Expr]types.TypeAndValue),
		Instances:    make(map[*ast.Ident]types.Object),
		Defs:         make(map[*ast.Ident]types.Object),
		Uses:         make(map[*ast.Ident]types.Object),
		Implicits:    make(map[ast.Node]types.Object),
		Selections:   make(map[*ast.SelectorExpr]*types.Selection),
		Scopes:       make(map[ast.Node]*types.Scope),
		InitOrder:    make([]*types.Initializer, 0),
		FileVersions: make(map[*ast.File]string),
	}
}

func (i *Info) GetTypes() map[ast.Expr]types.TypeAndValue {
	if i == nil {
		return nil
	}
	if i.Types == nil {
		return make(map[ast.Expr]types.TypeAndValue)
	}
	return i.Types
}
func (i *Info) GetInstances() map[*ast.Ident]types.Object {
	if i == nil {
		return nil
	}
	if i.Instances == nil {
		return make(map[*ast.Ident]types.Object)
	}
	return i.Instances
}
func (i *Info) GetDefs() map[*ast.Ident]types.Object {
	if i == nil {
		return nil
	}
	if i.Defs == nil {
		return make(map[*ast.Ident]types.Object)
	}
	return i.Defs
}
func (i *Info) GetUses() map[*ast.Ident]types.Object {
	if i == nil {
		return nil
	}
	if i.Uses == nil {
		return make(map[*ast.Ident]types.Object)
	}
	return i.Uses
}
func (i *Info) GetImplicits() map[ast.Node]types.Object {
	if i == nil {
		return nil
	}
	if i.Implicits == nil {
		return make(map[ast.Node]types.Object)
	}
	return i.Implicits
}
func (i *Info) GetSelections() map[*ast.SelectorExpr]*types.Selection {
	if i == nil {
		return nil
	}
	if i.Selections == nil {
		return make(map[*ast.SelectorExpr]*types.Selection)
	}
	return i.Selections
}
func (i *Info) GetScopes() map[ast.Node]*types.Scope {
	if i == nil {
		return nil
	}
	if i.Scopes == nil {
		return make(map[ast.Node]*types.Scope)
	}
	return i.Scopes
}
func (i *Info) GetInitOrder() []*types.Initializer {
	if i == nil {
		return nil
	}
	if i.InitOrder == nil {
		return make([]*types.Initializer, 0)
	}
	return i.InitOrder
}
func (i *Info) GetFileVersions() map[*ast.File]string {
	if i == nil {
		return nil
	}
	if i.FileVersions == nil {
		return make(map[*ast.File]string)
	}
	return i.FileVersions
}

func (i *Info) SetTypes(types map[ast.Expr]types.TypeAndValue) { i.Types = types }
func (i *Info) SetInstances(instances map[*ast.Ident]types.Object) {
	i.Instances = instances
}
func (i *Info) SetDefs(defs map[*ast.Ident]types.Object) { i.Defs = defs }
func (i *Info) SetUses(uses map[*ast.Ident]types.Object) { i.Uses = uses }
func (i *Info) SetImplicits(implicits map[ast.Node]types.Object) {
	i.Implicits = implicits
}
func (i *Info) SetSelections(selections map[*ast.SelectorExpr]*types.Selection) {
	i.Selections = selections
}
func (i *Info) SetScopes(scopes map[ast.Node]*types.Scope)  { i.Scopes = scopes }
func (i *Info) SetInitOrder(initOrder []*types.Initializer) { i.InitOrder = initOrder }
func (i *Info) SetFileVersions(fileVersions map[*ast.File]string) {
	i.FileVersions = fileVersions
}

func (i *Info) AddType(key ast.Expr, value types.TypeAndValue) {
	i.Types[key] = value
}
func (i *Info) AddInstance(key *ast.Ident, value types.Object) {
	i.Instances[key] = value
}
func (i *Info) AddDef(key *ast.Ident, value types.Object) {
	i.Defs[key] = value
}
func (i *Info) AddUse(key *ast.Ident, value types.Object) {
	i.Uses[key] = value
}
func (i *Info) AddImplicit(key ast.Node, value types.Object) {
	i.Implicits[key] = value
}
func (i *Info) AddSelection(key *ast.SelectorExpr, value *types.Selection) {
	i.Selections[key] = value
}
func (i *Info) AddScope(key ast.Node, value *types.Scope) { i.Scopes[key] = value }
func (i *Info) AddInitOrder(value *types.Initializer)     { i.InitOrder = append(i.InitOrder, value) }

func (i *Info) AddFileVersion(key *ast.File, value string) {
	i.FileVersions[key] = value
}
func (i *Info) GetFileVersion(key *ast.File) string {
	return i.FileVersions[key]
}
func (i *Info) RemoveFileVersion(key *ast.File) { delete(i.FileVersions, key) }
func (i *Info) ClearFileVersions()              { i.FileVersions = make(map[*ast.File]string) }
func (i *Info) Clear() {
	i.Types = make(map[ast.Expr]types.TypeAndValue)
	i.Instances = make(map[*ast.Ident]types.Object)
	i.Defs = make(map[*ast.Ident]types.Object)
	i.Uses = make(map[*ast.Ident]types.Object)
	i.Implicits = make(map[ast.Node]types.Object)
	i.Selections = make(map[*ast.SelectorExpr]*types.Selection)
	i.Scopes = make(map[ast.Node]*types.Scope)
	i.InitOrder = make([]*types.Initializer, 0)
	i.FileVersions = make(map[*ast.File]string)
}

/// astutil/nodes.go ///
package astutil

import "go/ast"

// ReplaceNode replaces a target AST node with a new one.
// Returns true if the replacement was applied.
func ReplaceNode(file *ast.File, target ast.Node, replacement ast.Node) bool {
	replaced := false
	ast.Inspect(file, func(n ast.Node) bool {
		switch node := n.(type) {
		case *ast.BlockStmt:
			for i, stmt := range node.List {
				if stmt == target {
					node.List[i] = replacement.(ast.Stmt)
					replaced = true
					return false
				}
			}
		}
		return true
	})
	return replaced
}

/// astutil/strings.go ///
package astutil

import (
	"go/ast"
	"go/token"
	"go/types"
	"unicode"
)

func DetectStringLikeConst(vs *ast.ValueSpec, ctx *TranspileContext) bool {
	if vs.Type != nil {
		if tv, ok := ctx.GetTypes()[vs.Type]; ok && tv.Type != nil {
			// Verifica se é alias de string
			if named, ok := tv.Type.(*types.Named); ok {
				if named.String() != "string" && tv.Type.Underlying().String() == "string" {
					return true
				}
			}
			// Ou string puro
			if tv.Type.Underlying().String() == "string" {
				return true
			}
		}
	}

	// Se não tem tipo explícito, mas tem valor literal string
	if len(vs.Values) > 0 {
		if bl, ok := vs.Values[0].(*ast.BasicLit); ok && bl.Kind == token.STRING {
			return false
		}
	}

	return false
}

func IsAllCaps(name string) bool {
	if name == "" {
		return false
	}
	hasLetter := false
	for _, r := range name {
		if unicode.IsLetter(r) {
			hasLetter = true
			if !unicode.IsUpper(r) {
				return false
			}
		}
	}
	return hasLetter
}

func IsAllLower(name string) bool {
	if name == "" {
		return false
	}
	hasLetter := false
	for _, r := range name {
		if unicode.IsLetter(r) {
			hasLetter = true
			if !unicode.IsLower(r) {
				return false
			}
		}
	}
	return hasLetter
}

func IsConstant(name string) bool {
	if name == "" {
		return false
	}
	for _, r := range name {
		if !unicode.IsLetter(r) && !unicode.IsDigit(r) && r != '_' && r != '$' {
			return false
		}
	}
	return true
}

func IsIdentifier(name string) bool {
	if name == "" {
		return false
	}
	for i, r := range name {
		if i == 0 && !unicode.IsLetter(r) {
			return false
		}
		if !unicode.IsLetter(r) && !unicode.IsDigit(r) && r != '_' && r != '$' {
			return false
		}
	}
	return true
}

func IsVar(name string) bool {
	if name == "" {
		return false
	}
	for i, r := range name {
		if i == 0 && !unicode.IsLetter(r) {
			return false
		}
		if !unicode.IsLetter(r) && !unicode.IsDigit(r) && r != '_' && r != '$' {
			return false
		}
	}
	return true
}

/// astutil/types.go ///
package astutil

// MenorTipoParaFlags retorna o tipo de inteiro necessário para armazenar as flags
func MenorTipoParaFlags(numFlags int) string {
	switch {
	case numFlags <= 8:
		return "uint8"
	case numFlags <= 16:
		return "uint16"
	case numFlags <= 32:
		return "uint32"
	default:
		return "uint64"
	}
}

// GetConstNames returns the constant names for fields
func GetConstNames(fields []string) []string {
	names := make([]string, len(fields))
	for i, field := range fields {
		names[i] = "Flag" + field
	}
	return names
}

/// engine/advanced_generator.go ///
// Package transpiler implementa geração de código avançado com obfuscação e estados bitwise
package transpiler

import (
	"crypto/rand"
	"fmt"
	"math/big"
	"strings"
)

// AdvancedCodeGenerator gera código Go ultra-otimizado com obfuscação
type AdvancedCodeGenerator struct {
	contexts              []LogicalContext
	obfuscationLevel      int               // 1=low, 2=medium, 3=high
	nameObfuscation       map[string]string // Mapeamento de nomes obfuscados
	stateRegistry         map[string]uint64 // Registro de estados globais
	jumpTableRegistry     map[string]string // Registro de jump tables
	globalSystemGenerated bool              // Flag para evitar duplicar sistema global
}

// NewAdvancedCodeGenerator cria um novo gerador avançado
func NewAdvancedCodeGenerator(obfuscationLevel int) *AdvancedCodeGenerator {
	return &AdvancedCodeGenerator{
		contexts:              []LogicalContext{},
		obfuscationLevel:      obfuscationLevel,
		nameObfuscation:       make(map[string]string),
		stateRegistry:         make(map[string]uint64),
		jumpTableRegistry:     make(map[string]string),
		globalSystemGenerated: false,
	}
}

// GenerateAdvancedCode gera código completo com todas as otimizações
func (acg *AdvancedCodeGenerator) GenerateAdvancedCode(filename string, contexts []LogicalContext) (string, error) {
	acg.contexts = contexts

	var output strings.Builder

	// Header ultra-otimizado
	output.WriteString(acg.generateHeader(filename))

	// Global state system - apenas gerar uma vez
	if !acg.globalSystemGenerated {
		output.WriteString(acg.generateGlobalStateSystem())
		output.WriteString(acg.generateObfuscatedUtilities())
		acg.globalSystemGenerated = true
	}

	// Process each context
	for _, context := range contexts {
		if context.Transpilable {
			switch context.Type {
			case "struct":
				output.WriteString(acg.GenerateOptimizedStruct(context))
			case "function":
				output.WriteString(acg.GenerateOptimizedFunction(context))
			case "auth_logic":
				output.WriteString(acg.GenerateObfuscatedAuth(context))
			case "if_chain":
				output.WriteString(acg.GenerateJumpTable(context))
			case "switch":
				output.WriteString(acg.GenerateBitwiseSwitch(context))
			}
		}
	}

	// Main function apenas no primeiro arquivo ou se não tiver main ainda
	if !acg.globalSystemGenerated {
		output.WriteString(acg.generateOptimizedMain())
	}

	return output.String(), nil
}

// generateHeader gera header ultra-otimizado
func (acg *AdvancedCodeGenerator) generateHeader(filename string) string {
	var header strings.Builder

	header.WriteString("// Generated by GASType Revolutionary Transpiler\n")
	header.WriteString("// Source: " + filename + "\n")
	header.WriteString("// ULTRA-OPTIMIZED BITWISE STATE MACHINE - PERFORMANCE LEVEL: SURREAL\n")
	header.WriteString("// OBFUSCATION LEVEL: " + acg.getObfuscationLevelName() + "\n")
	header.WriteString("// WARNING: Human-readable logic has been eliminated for maximum performance\n\n")

	header.WriteString("package main\n\n")
	header.WriteString("import (\n")
	header.WriteString("\t\"fmt\"\n")
	header.WriteString("\t\"unsafe\"\n")
	header.WriteString(")\n\n")

	return header.String()
}

// getObfuscationLevelName retorna nome do nível de obfuscação
func (acg *AdvancedCodeGenerator) getObfuscationLevelName() string {
	switch acg.obfuscationLevel {
	case 1:
		return "LOW (semantic preservation)"
	case 2:
		return "MEDIUM (balanced optimization)"
	case 3:
		return "HIGH (maximum obfuscation)"
	default:
		return "UNKNOWN"
	}
}

// generateGlobalStateSystem gera sistema de estados global
func (acg *AdvancedCodeGenerator) generateGlobalStateSystem() string {
	var output strings.Builder

	output.WriteString("// Global State System - Ultra-compact bitwise state management\n")
	output.WriteString("type SystemState uint64\n\n")

	// Estado global obfuscado
	globalStateName := acg.obfuscateName("globalState")
	output.WriteString(fmt.Sprintf("var %s SystemState\n\n", globalStateName))

	// Constantes de estado (obfuscadas)
	output.WriteString("// System state constants (obfuscated)\n")
	output.WriteString("const (\n")

	stateNames := []string{
		"SystemInit", "ProcessingActive", "AuthValidated",
		"DataLoaded", "CacheReady", "ErrorDetected",
		"ShutdownRequested", "PerformanceMode",
	}

	for i, stateName := range stateNames {
		obfuscatedName := acg.obfuscateName(stateName)
		if i == 0 {
			output.WriteString(fmt.Sprintf("\t%s SystemState = 1 << iota\n", obfuscatedName))
		} else {
			output.WriteString(fmt.Sprintf("\t%s\n", obfuscatedName))
		}
		acg.stateRegistry[stateName] = 1 << uint64(i)
	}

	output.WriteString(")\n\n")

	// Funções de manipulação de estado (obfuscadas)
	setStateName := acg.obfuscateName("setState")
	clearStateName := acg.obfuscateName("clearState")
	hasStateName := acg.obfuscateName("hasState")

	output.WriteString(fmt.Sprintf("// %s sets system state (ultra-fast bitwise)\n", setStateName))
	output.WriteString(fmt.Sprintf("func %s(s SystemState) {\n", setStateName))
	output.WriteString(fmt.Sprintf("\t%s |= s\n", globalStateName))
	output.WriteString("}\n\n")

	output.WriteString(fmt.Sprintf("// %s clears system state (ultra-fast bitwise)\n", clearStateName))
	output.WriteString(fmt.Sprintf("func %s(s SystemState) {\n", clearStateName))
	output.WriteString(fmt.Sprintf("\t%s &^= s\n", globalStateName))
	output.WriteString("}\n\n")

	output.WriteString(fmt.Sprintf("// %s checks system state (ultra-fast bitwise)\n", hasStateName))
	output.WriteString(fmt.Sprintf("func %s(s SystemState) bool {\n", hasStateName))
	output.WriteString(fmt.Sprintf("\treturn %s&s != 0\n", globalStateName))
	output.WriteString("}\n\n")

	return output.String()
}

// generateObfuscatedUtilities gera funções utilitárias obfuscadas
func (acg *AdvancedCodeGenerator) generateObfuscatedUtilities() string {
	var output strings.Builder

	output.WriteString("// Obfuscated utility functions - Maximum performance bitwise operations\n\n")

	// Função de contagem de bits (obfuscada)
	popCountName := acg.obfuscateName("popCount")
	output.WriteString(fmt.Sprintf("// %s - ultra-fast bit counting (performance critical)\n", popCountName))
	output.WriteString(fmt.Sprintf("func %s(x uint64) int {\n", popCountName))
	output.WriteString("\treturn int(x&1) + int((x>>1)&1) + int((x>>2)&1) + int((x>>3)&1) +\n")
	output.WriteString("\t       int((x>>4)&1) + int((x>>5)&1) + int((x>>6)&1) + int((x>>7)&1)\n")
	output.WriteString("}\n\n")

	// Jump table generator (obfuscado)
	jumpTableName := acg.obfuscateName("jumpTable")
	output.WriteString(fmt.Sprintf("// %s - ultra-fast conditional execution\n", jumpTableName))
	output.WriteString(fmt.Sprintf("func %s(state uint64, table map[uint64]func()) {\n", jumpTableName))
	output.WriteString("\tif fn, exists := table[state]; exists {\n")
	output.WriteString("\t\tfn()\n")
	output.WriteString("\t}\n")
	output.WriteString("}\n\n")

	// Obfuscated byte operations
	toByteArrayName := acg.obfuscateName("toByteArray")
	fromByteArrayName := acg.obfuscateName("fromByteArray")

	output.WriteString(fmt.Sprintf("// %s - convert state to bytes for network transmission\n", toByteArrayName))
	output.WriteString(fmt.Sprintf("func %s(v uint64) []byte {\n", toByteArrayName))
	output.WriteString("\treturn (*[8]byte)(unsafe.Pointer(&v))[:]\n")
	output.WriteString("}\n\n")

	output.WriteString(fmt.Sprintf("// %s - reconstruct state from bytes\n", fromByteArrayName))
	output.WriteString(fmt.Sprintf("func %s(b []byte) uint64 {\n", fromByteArrayName))
	output.WriteString("\tif len(b) < 8 { return 0 }\n")
	output.WriteString("\treturn *(*uint64)(unsafe.Pointer(&b[0]))\n")
	output.WriteString("}\n\n")

	return output.String()
}

// GenerateOptimizedStruct gera struct otimizada (já implementado, mas aprimorado)
func (acg *AdvancedCodeGenerator) GenerateOptimizedStruct(context LogicalContext) string {
	var output strings.Builder

	structName := context.Name
	obfuscatedStructName := acg.obfuscateName(structName + "Bitwise")
	flagTypeName := acg.obfuscateName(structName + "Flags")

	output.WriteString(fmt.Sprintf("// %s - Ultra-optimized bitwise struct (replaces %s)\n", obfuscatedStructName, structName))
	output.WriteString(fmt.Sprintf("type %s uint64\n\n", flagTypeName))

	// Constantes obfuscadas
	output.WriteString("const (\n")
	for i, state := range context.BitStates {
		obfuscatedConstName := acg.obfuscateName(fmt.Sprintf("Flag_%s_%s", structName, state.Name))
		if i == 0 {
			output.WriteString(fmt.Sprintf("\t%s %s = 1 << iota\n", obfuscatedConstName, flagTypeName))
		} else {
			output.WriteString(fmt.Sprintf("\t%s\n", obfuscatedConstName))
		}
	}
	output.WriteString(")\n\n")

	// Struct otimizada
	output.WriteString(fmt.Sprintf("type %s struct {\n", obfuscatedStructName))
	output.WriteString(fmt.Sprintf("\tFlags %s\n", flagTypeName))
	output.WriteString("}\n\n")

	// Métodos ultra-otimizados (obfuscados)
	setMethodName := acg.obfuscateName("set")
	clearMethodName := acg.obfuscateName("clear")
	hasMethodName := acg.obfuscateName("has")

	output.WriteString(fmt.Sprintf("func (s *%s) %s(f %s) { s.Flags |= f }\n", obfuscatedStructName, setMethodName, flagTypeName))
	output.WriteString(fmt.Sprintf("func (s *%s) %s(f %s) { s.Flags &^= f }\n", obfuscatedStructName, clearMethodName, flagTypeName))
	output.WriteString(fmt.Sprintf("func (s *%s) %s(f %s) bool { return s.Flags&f != 0 }\n\n", obfuscatedStructName, hasMethodName, flagTypeName))

	return output.String()
}

// GenerateObfuscatedAuth gera autenticação obfuscada (como no manifesto)
func (acg *AdvancedCodeGenerator) GenerateObfuscatedAuth(context LogicalContext) string {
	var output strings.Builder

	originalName := context.Name
	obfuscatedName := acg.generateRandomName()

	output.WriteString(fmt.Sprintf("// %s - Obfuscated authentication (was: %s)\n", obfuscatedName, originalName))
	output.WriteString(fmt.Sprintf("func %s(i0 string) bool {\n", obfuscatedName))
	output.WriteString("\tvar k4 uint8\n")
	output.WriteString("\tk4 |= 1 << 0 // auth-check bit\n\n")

	// Lógica obfuscada usando byte array (como no manifesto)
	output.WriteString("\treturn map[bool]bool{\n")
	output.WriteString("\t\t(func(s string) bool {\n")
	output.WriteString("\t\t\treturn s == string([]byte{97, 100, 109, 105, 110}) // \"admin\" obfuscated\n")
	output.WriteString("\t\t})(i0): true,\n")
	output.WriteString("\t}[true]\n")
	output.WriteString("}\n\n")

	return output.String()
}

// GenerateJumpTable gera jump table para if/else chains
func (acg *AdvancedCodeGenerator) GenerateJumpTable(context LogicalContext) string {
	var output strings.Builder

	jumpTableName := acg.obfuscateName("jumpTable_" + context.Name)

	output.WriteString(fmt.Sprintf("// %s - Ultra-fast jump table (replaces if/else chain)\n", jumpTableName))
	output.WriteString(fmt.Sprintf("func %s(condition uint64) {\n", jumpTableName))
	output.WriteString("\ttable := map[uint64]func(){\n")

	for i := range context.BitStates {
		actionName := acg.obfuscateName(fmt.Sprintf("action_%d", i))
		output.WriteString(fmt.Sprintf("\t\t%d: %s,\n", 1<<uint64(i), actionName))
	}

	output.WriteString("\t}\n")
	output.WriteString("\tif fn, exists := table[condition]; exists {\n")
	output.WriteString("\t\tfn()\n")
	output.WriteString("\t}\n")
	output.WriteString("}\n\n")

	// Gerar funções de ação
	for i := range context.BitStates {
		actionName := acg.obfuscateName(fmt.Sprintf("action_%d", i))
		output.WriteString(fmt.Sprintf("func %s() {\n", actionName))
		output.WriteString(fmt.Sprintf("\t// Optimized action %d logic\n", i))
		output.WriteString("}\n\n")
	}

	return output.String()
}

// GenerateBitwiseSwitch gera switch otimizado com bitwise
func (acg *AdvancedCodeGenerator) GenerateBitwiseSwitch(context LogicalContext) string {
	var output strings.Builder

	switchName := acg.obfuscateName("bitwiseSwitch_" + context.Name)

	output.WriteString(fmt.Sprintf("// %s - Ultra-optimized switch using bitwise operations\n", switchName))
	output.WriteString(fmt.Sprintf("func %s(selector uint64) {\n", switchName))
	output.WriteString("\tswitch {\n")

	for i := range context.BitStates {
		bitMask := 1 << uint64(i)
		output.WriteString(fmt.Sprintf("\tcase selector&%d != 0:\n", bitMask))
		output.WriteString(fmt.Sprintf("\t\t// Case %d: optimized logic\n", i))
		output.WriteString("\t\t// Bitwise operation here\n")
	}

	output.WriteString("\t}\n")
	output.WriteString("}\n\n")

	return output.String()
}

// GenerateOptimizedFunction gera função otimizada
func (acg *AdvancedCodeGenerator) GenerateOptimizedFunction(context LogicalContext) string {
	var output strings.Builder

	originalName := context.Name
	obfuscatedName := acg.obfuscateName(originalName)

	output.WriteString(fmt.Sprintf("// %s - Ultra-optimized function (was: %s)\n", obfuscatedName, originalName))
	output.WriteString(fmt.Sprintf("func %s() {\n", obfuscatedName))
	output.WriteString("\t// Function logic converted to bitwise state machine\n")
	output.WriteString("\tvar state uint64\n")

	for i, bitState := range context.BitStates {
		output.WriteString(fmt.Sprintf("\tstate |= 1 << %d // %s\n", i, bitState.Name))
	}

	output.WriteString("\t// Execute based on state\n")
	output.WriteString("\tif state&7 == 7 { // All states active\n")
	output.WriteString("\t\t// Optimized execution path\n")
	output.WriteString("\t}\n")
	output.WriteString("}\n\n")

	return output.String()
}

// generateOptimizedMain gera main function ultra-otimizada
func (acg *AdvancedCodeGenerator) generateOptimizedMain() string {
	var output strings.Builder

	output.WriteString("// Ultra-optimized main function - Surreal performance level\n")
	output.WriteString("func main() {\n")
	output.WriteString("\tfmt.Println(\"🚀 GASType Revolutionary Code - SURREAL PERFORMANCE ACTIVE!\")\n\n")

	// Inicializar sistema de estados
	setStateName := acg.obfuscateName("setState")
	initStateName := acg.obfuscateName("SystemInit")

	output.WriteString("\t// Initialize ultra-fast state system\n")
	output.WriteString(fmt.Sprintf("\t%s(%s)\n\n", setStateName, initStateName))

	// Demonstração de performance
	output.WriteString("\t// Performance demonstration\n")
	output.WriteString("\tvar perfState uint64 = 0b11010110 // Binary state representation\n")
	output.WriteString("\tfmt.Printf(\"⚡ System state: %%064b\\n\", perfState)\n")

	popCountName := acg.obfuscateName("popCount")
	output.WriteString(fmt.Sprintf("\tfmt.Printf(\"🔥 Active features: %%d/8\\n\", %s(perfState))\n\n", popCountName))

	// Exemplo de jump table
	if len(acg.jumpTableRegistry) > 0 {
		for tableName := range acg.jumpTableRegistry {
			output.WriteString("\t// Execute ultra-fast jump table\n")
			output.WriteString(fmt.Sprintf("\t%s(perfState)\n", tableName))
			break // Apenas um exemplo
		}
	}

	output.WriteString("\n\tfmt.Println(\"✅ Revolutionary transpilation complete - Human logic eliminated!\")\n")
	output.WriteString("}\n")

	return output.String()
}

// obfuscateName obfusca um nome baseado no nível de obfuscação
func (acg *AdvancedCodeGenerator) obfuscateName(originalName string) string {
	if obfuscated, exists := acg.nameObfuscation[originalName]; exists {
		return obfuscated
	}

	var obfuscatedName string

	switch acg.obfuscationLevel {
	case 1: // Low - manter semântica parcial
		obfuscatedName = strings.ToLower(originalName[:1]) + generateRandomString(4)
	case 2: // Medium - obfuscação moderada
		obfuscatedName = generateRandomString(6) + "_" + generateRandomString(2)
	case 3: // High - obfuscação máxima
		obfuscatedName = acg.generateRandomName()
	default:
		obfuscatedName = originalName
	}

	acg.nameObfuscation[originalName] = obfuscatedName
	return obfuscatedName
}

// generateRandomName gera nome completamente aleatório
func (acg *AdvancedCodeGenerator) generateRandomName() string {
	prefixes := []string{"Jf", "Kx", "Zm", "Qp", "Wv", "Bh", "Ny", "Lg"}
	suffixes := []string{"8sZ", "91x", "4mP", "7vQ", "2nR", "6kL", "9wE", "3tY"}

	prefix := prefixes[acg.randomInt(len(prefixes))]
	suffix := suffixes[acg.randomInt(len(suffixes))]
	middle := generateRandomString(2)

	return prefix + middle + "_" + suffix
}

// generateRandomString gera string aleatória
func generateRandomString(length int) string {
	chars := "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	result := make([]byte, length)

	for i := 0; i < length; i++ {
		num, _ := rand.Int(rand.Reader, big.NewInt(int64(len(chars))))
		result[i] = chars[num.Int64()]
	}

	return string(result)
}

// randomInt gera número aleatório
func (acg *AdvancedCodeGenerator) randomInt(max int) int {
	num, _ := rand.Int(rand.Reader, big.NewInt(int64(max)))
	return int(num.Int64())
}

/// engine/context_analyzer.go ///
// Package transpiler implementa análise de contextos lógicos para transpilação avançada
package transpiler

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"strings"
)

// LogicalContext representa um contexto lógico que pode ser transpilado
type LogicalContext struct {
	Type         string     // "function", "if_chain", "switch", "struct", "auth_logic"
	Name         string     // Nome do contexto (função, variável, etc.)
	Complexity   int        // Nível de complexidade (1-10)
	Transpilable bool       // Se pode ser transpilado para bitwise
	Dependencies []string   // Dependências de outros contextos
	ASTNode      ast.Node   // Nó AST original
	BitStates    []BitState // Estados bitwise possíveis
	StartLine    int        // Linha de início
	EndLine      int        // Linha de fim
}

// BitState representa um estado bitwise possível
type BitState struct {
	Name        string   // Nome semântico do estado
	BitPosition int      // Posição do bit (0-63)
	Conditions  []string // Condições que ativam este estado
	Actions     []string // Ações executadas quando ativo
}

// ContextAnalyzer analisa código Go e identifica contextos transpiláveis
type ContextAnalyzer struct {
	fset     *token.FileSet
	contexts []LogicalContext
}

// NewContextAnalyzer cria um novo analisador de contextos
func NewContextAnalyzer() *ContextAnalyzer {
	return &ContextAnalyzer{
		fset:     token.NewFileSet(),
		contexts: []LogicalContext{},
	}
}

// AnalyzeFile analisa um arquivo e identifica contextos lógicos
func (ca *ContextAnalyzer) AnalyzeFile(filename string) ([]LogicalContext, error) {
	node, err := parser.ParseFile(ca.fset, filename, nil, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("erro ao parsear arquivo: %w", err)
	}

	ca.contexts = []LogicalContext{}

	// Análise de contextos diferentes
	ca.analyzeStructs(node)
	ca.analyzeFunctions(node)
	ca.analyzeIfChains(node)
	ca.analyzeAuthLogic(node)
	ca.analyzeSwitchStatements(node)

	// Calcular transpilabilidade e dependências
	ca.calculateTranspilability()

	return ca.contexts, nil
}

// analyzeStructs analisa structs para conversão bitwise (já implementado)
func (ca *ContextAnalyzer) analyzeStructs(node *ast.File) {
	ast.Inspect(node, func(n ast.Node) bool {
		if typeSpec, ok := n.(*ast.TypeSpec); ok {
			if structType, ok := typeSpec.Type.(*ast.StructType); ok {
				context := ca.analyzeStruct(typeSpec, structType)
				if context != nil {
					ca.contexts = append(ca.contexts, *context)
				}
			}
		}
		return true
	})
}

// analyzeStruct analisa uma struct específica
func (ca *ContextAnalyzer) analyzeStruct(typeSpec *ast.TypeSpec, structType *ast.StructType) *LogicalContext {
	var boolFields []string
	var bitStates []BitState

	for _, field := range structType.Fields.List {
		if ident, ok := field.Type.(*ast.Ident); ok && ident.Name == "bool" {
			for _, name := range field.Names {
				boolFields = append(boolFields, name.Name)
				bitStates = append(bitStates, BitState{
					Name:        name.Name,
					BitPosition: len(bitStates),
					Conditions:  []string{fmt.Sprintf("Set%s(true)", name.Name)},
					Actions:     []string{fmt.Sprintf("Execute_%s_Logic", name.Name)},
				})
			}
		}
	}

	if len(boolFields) == 0 {
		return nil
	}

	pos := ca.fset.Position(typeSpec.Pos())
	endPos := ca.fset.Position(typeSpec.End())

	return &LogicalContext{
		Type:         "struct",
		Name:         typeSpec.Name.Name,
		Complexity:   len(boolFields), // Complexidade = número de campos bool
		Transpilable: true,
		Dependencies: []string{},
		ASTNode:      typeSpec,
		BitStates:    bitStates,
		StartLine:    pos.Line,
		EndLine:      endPos.Line,
	}
}

// analyzeFunctions analisa funções para obfuscação e transpilação
func (ca *ContextAnalyzer) analyzeFunctions(node *ast.File) {
	ast.Inspect(node, func(n ast.Node) bool {
		if funcDecl, ok := n.(*ast.FuncDecl); ok {
			context := ca.analyzeFunction(funcDecl)
			if context != nil {
				ca.contexts = append(ca.contexts, *context)
			}
		}
		return true
	})
}

// analyzeFunction analisa uma função específica
func (ca *ContextAnalyzer) analyzeFunction(funcDecl *ast.FuncDecl) *LogicalContext {
	if funcDecl.Name == nil {
		return nil
	}

	pos := ca.fset.Position(funcDecl.Pos())
	endPos := ca.fset.Position(funcDecl.End())

	// Analisar complexidade da função
	complexity := ca.calculateFunctionComplexity(funcDecl)
	transpilable := complexity <= 5 // Funções simples são transpiláveis

	context := &LogicalContext{
		Type:         "function",
		Name:         funcDecl.Name.Name,
		Complexity:   complexity,
		Transpilable: transpilable,
		Dependencies: []string{},
		ASTNode:      funcDecl,
		BitStates:    []BitState{},
		StartLine:    pos.Line,
		EndLine:      endPos.Line,
	}

	// Se for transpilável, criar estados bitwise
	if transpilable {
		context.BitStates = ca.createFunctionBitStates(funcDecl)
	}

	return context
}

// calculateFunctionComplexity calcula complexidade de uma função
func (ca *ContextAnalyzer) calculateFunctionComplexity(funcDecl *ast.FuncDecl) int {
	complexity := 1 // Base

	ast.Inspect(funcDecl, func(n ast.Node) bool {
		switch n.(type) {
		case *ast.IfStmt:
			complexity += 2
		case *ast.ForStmt, *ast.RangeStmt:
			complexity += 3
		case *ast.SwitchStmt, *ast.TypeSwitchStmt:
			complexity += 2
		case *ast.CallExpr:
			complexity += 1
		}
		return true
	})

	return complexity
}

// createFunctionBitStates cria estados bitwise para uma função
func (ca *ContextAnalyzer) createFunctionBitStates(funcDecl *ast.FuncDecl) []BitState {
	states := []BitState{
		{
			Name:        "function_entry",
			BitPosition: 0,
			Conditions:  []string{"function_called"},
			Actions:     []string{"initialize_context"},
		},
		{
			Name:        "function_processing",
			BitPosition: 1,
			Conditions:  []string{"parameters_validated"},
			Actions:     []string{"execute_logic"},
		},
		{
			Name:        "function_exit",
			BitPosition: 2,
			Conditions:  []string{"logic_completed"},
			Actions:     []string{"return_result"},
		},
	}

	return states
}

// analyzeIfChains analisa cadeias de if/else para conversão em jump tables
func (ca *ContextAnalyzer) analyzeIfChains(node *ast.File) {
	ast.Inspect(node, func(n ast.Node) bool {
		if ifStmt, ok := n.(*ast.IfStmt); ok {
			context := ca.analyzeIfChain(ifStmt)
			if context != nil {
				ca.contexts = append(ca.contexts, *context)
			}
		}
		return true
	})
}

// analyzeIfChain analisa uma cadeia de if/else
func (ca *ContextAnalyzer) analyzeIfChain(ifStmt *ast.IfStmt) *LogicalContext {
	chainLength := ca.calculateIfChainLength(ifStmt)

	if chainLength < 2 {
		return nil // Muito simples para otimizar
	}

	pos := ca.fset.Position(ifStmt.Pos())
	endPos := ca.fset.Position(ifStmt.End())

	context := &LogicalContext{
		Type:         "if_chain",
		Name:         fmt.Sprintf("if_chain_line_%d", pos.Line),
		Complexity:   chainLength,
		Transpilable: chainLength >= 3, // Cadeias com 3+ condições são transpiláveis
		Dependencies: []string{},
		ASTNode:      ifStmt,
		BitStates:    ca.createIfChainBitStates(ifStmt, chainLength),
		StartLine:    pos.Line,
		EndLine:      endPos.Line,
	}

	return context
}

// calculateIfChainLength calcula o comprimento de uma cadeia if/else
func (ca *ContextAnalyzer) calculateIfChainLength(ifStmt *ast.IfStmt) int {
	length := 1
	current := ifStmt

	for current.Else != nil {
		length++
		if elseIf, ok := current.Else.(*ast.IfStmt); ok {
			current = elseIf
		} else {
			break
		}
	}

	return length
}

// createIfChainBitStates cria estados bitwise para cadeia if/else
func (ca *ContextAnalyzer) createIfChainBitStates(ifStmt *ast.IfStmt, chainLength int) []BitState {
	states := []BitState{}

	for i := 0; i < chainLength; i++ {
		state := BitState{
			Name:        fmt.Sprintf("condition_%d", i),
			BitPosition: i,
			Conditions:  []string{fmt.Sprintf("evaluate_condition_%d", i)},
			Actions:     []string{fmt.Sprintf("execute_branch_%d", i)},
		}
		states = append(states, state)
	}

	return states
}

// analyzeAuthLogic analisa lógicas de autenticação para obfuscação
func (ca *ContextAnalyzer) analyzeAuthLogic(node *ast.File) {
	ast.Inspect(node, func(n ast.Node) bool {
		if funcDecl, ok := n.(*ast.FuncDecl); ok {
			if ca.isAuthFunction(funcDecl) {
				context := ca.analyzeAuthFunction(funcDecl)
				if context != nil {
					ca.contexts = append(ca.contexts, *context)
				}
			}
		}
		return true
	})
}

// isAuthFunction verifica se uma função é de autenticação
func (ca *ContextAnalyzer) isAuthFunction(funcDecl *ast.FuncDecl) bool {
	if funcDecl.Name == nil {
		return false
	}

	name := strings.ToLower(funcDecl.Name.Name)
	authKeywords := []string{"auth", "login", "check", "verify", "validate", "permission"}

	for _, keyword := range authKeywords {
		if strings.Contains(name, keyword) {
			return true
		}
	}

	return false
}

// analyzeAuthFunction analisa função de autenticação
func (ca *ContextAnalyzer) analyzeAuthFunction(funcDecl *ast.FuncDecl) *LogicalContext {
	pos := ca.fset.Position(funcDecl.Pos())
	endPos := ca.fset.Position(funcDecl.End())

	context := &LogicalContext{
		Type:         "auth_logic",
		Name:         funcDecl.Name.Name,
		Complexity:   8,    // Autenticação é sempre complexa
		Transpilable: true, // Sempre transpilável para segurança
		Dependencies: []string{},
		ASTNode:      funcDecl,
		BitStates:    ca.createAuthBitStates(),
		StartLine:    pos.Line,
		EndLine:      endPos.Line,
	}

	return context
}

// createAuthBitStates cria estados bitwise para autenticação
func (ca *ContextAnalyzer) createAuthBitStates() []BitState {
	return []BitState{
		{
			Name:        "auth_check_init",
			BitPosition: 0,
			Conditions:  []string{"user_input_received"},
			Actions:     []string{"validate_input_format"},
		},
		{
			Name:        "auth_processing",
			BitPosition: 1,
			Conditions:  []string{"input_valid"},
			Actions:     []string{"perform_obfuscated_check"},
		},
		{
			Name:        "auth_result",
			BitPosition: 2,
			Conditions:  []string{"check_completed"},
			Actions:     []string{"return_auth_status"},
		},
	}
}

// analyzeSwitchStatements analisa switch statements para otimização
func (ca *ContextAnalyzer) analyzeSwitchStatements(node *ast.File) {
	ast.Inspect(node, func(n ast.Node) bool {
		if switchStmt, ok := n.(*ast.SwitchStmt); ok {
			context := ca.analyzeSwitchStatement(switchStmt)
			if context != nil {
				ca.contexts = append(ca.contexts, *context)
			}
		}
		return true
	})
}

// analyzeSwitchStatement analisa um switch statement
func (ca *ContextAnalyzer) analyzeSwitchStatement(switchStmt *ast.SwitchStmt) *LogicalContext {
	caseCount := len(switchStmt.Body.List)

	if caseCount < 3 {
		return nil // Muito simples
	}

	pos := ca.fset.Position(switchStmt.Pos())
	endPos := ca.fset.Position(switchStmt.End())

	context := &LogicalContext{
		Type:         "switch",
		Name:         fmt.Sprintf("switch_line_%d", pos.Line),
		Complexity:   caseCount,
		Transpilable: true,
		Dependencies: []string{},
		ASTNode:      switchStmt,
		BitStates:    ca.createSwitchBitStates(caseCount),
		StartLine:    pos.Line,
		EndLine:      endPos.Line,
	}

	return context
}

// createSwitchBitStates cria estados bitwise para switch
func (ca *ContextAnalyzer) createSwitchBitStates(caseCount int) []BitState {
	states := []BitState{}

	for i := 0; i < caseCount; i++ {
		state := BitState{
			Name:        fmt.Sprintf("case_%d", i),
			BitPosition: i,
			Conditions:  []string{fmt.Sprintf("match_case_%d", i)},
			Actions:     []string{fmt.Sprintf("execute_case_%d", i)},
		}
		states = append(states, state)
	}

	return states
}

// calculateTranspilability calcula a transpilabilidade de todos os contextos
func (ca *ContextAnalyzer) calculateTranspilability() {
	for i := range ca.contexts {
		context := &ca.contexts[i]

		// Fatores que influenciam transpilabilidade
		if context.Complexity > 10 {
			context.Transpilable = false
		}

		if context.Type == "auth_logic" {
			context.Transpilable = true // Sempre transpilável para segurança
		}

		// Calcular dependências entre contextos
		ca.calculateDependencies(context)
	}
}

// calculateDependencies calcula dependências entre contextos
func (ca *ContextAnalyzer) calculateDependencies(context *LogicalContext) {
	// TODO: Implementar análise de dependências
	// Por enquanto, deixar vazio
	context.Dependencies = []string{}
}

// GetTranspilableContexts retorna apenas contextos transpiláveis
func (ca *ContextAnalyzer) GetTranspilableContexts() []LogicalContext {
	var transpilable []LogicalContext

	for _, context := range ca.contexts {
		if context.Transpilable {
			transpilable = append(transpilable, context)
		}
	}

	return transpilable
}

// GetContextsByType retorna contextos de um tipo específico
func (ca *ContextAnalyzer) GetContextsByType(contextType string) []LogicalContext {
	var filtered []LogicalContext

	for _, context := range ca.contexts {
		if context.Type == contextType {
			filtered = append(filtered, context)
		}
	}

	return filtered
}

/// engine/engine.go ///
// Package transpiler provides a modular engine for Go AST transformations
package transpiler

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/fs"
	"path/filepath"
	"strings"

	"github.com/rafa-mori/gastype/internal/astutil"
)

// Engine coordinates passes and context for transpilation
type Engine struct {
	Ctx    *astutil.TranspileContext
	Passes []TranspilePass
}

// TranspilePass interface for any AST transformation
type TranspilePass interface {
	Name() string
	Apply(file *ast.File, fset *token.FileSet, ctx *astutil.TranspileContext) error
}

// DiscoverGoFiles discovers all Go files recursively
func DiscoverGoFiles(root string) ([]string, error) {
	var files []string
	err := filepath.WalkDir(root, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if !d.IsDir() && strings.HasSuffix(path, ".go") && !strings.HasSuffix(path, "_test.go") {
			files = append(files, path)
		}
		return nil
	})
	return files, err
}

// NewEngine creates a new transpilation engine
func NewEngine(ctx *astutil.TranspileContext) *Engine {
	return &Engine{
		Ctx:    ctx,
		Passes: make([]TranspilePass, 0),
	}
}

// AddPass adds a transpilation pass to the engine
func (e *Engine) AddPass(pass TranspilePass) {
	e.Passes = append(e.Passes, pass)
}

// Run executes the engine on the specified root path
func (e *Engine) Run(root string) error {
	files, err := DiscoverGoFiles(root)
	if err != nil {
		return fmt.Errorf("failed to discover Go files: %w", err)
	}

	fmt.Printf("🚀 Starting transpilation engine on %d files\n", len(files))

	processedFiles := 0
	transformedFiles := 0

	for _, filePath := range files {
		fmt.Printf("🔍 Processing %s\n", filePath)
		// 🚀 REVOLUTIONARY: Use shared FileSet from context
		astFile, err := parser.ParseFile(e.Ctx.Fset, filePath, nil, parser.ParseComments)
		if err != nil {
			fmt.Printf("  ⚠️  Failed to parse %s: %v\n", filePath, err)
			continue
		}

		fileTransformed := false
		for _, pass := range e.Passes {
			fmt.Printf("  ⚙️  Applying pass: %s\n", pass.Name())
			// 🚀 REVOLUTIONARY: Use shared FileSet in passes
			if err := pass.Apply(astFile, e.Ctx.Fset, e.Ctx); err != nil {
				return fmt.Errorf("pass %s failed on %s: %w", pass.Name(), filePath, err)
			}
			fileTransformed = true
		}

		if fileTransformed {
			transformedFiles++
			// 🚀 REVOLUTIONARY: Store transformed files for OutputManager
			e.Ctx.GeneratedFiles[filePath] = astFile
			fmt.Printf("  ✅ File transformed and stored: %s\n", filePath)
		}

		processedFiles++
	}

	fmt.Printf("📊 Engine summary: %d files processed, %d transformed\n", processedFiles, transformedFiles)
	fmt.Printf("🎯 Ready for OutputManager: %d files stored\n", len(e.Ctx.GeneratedFiles))

	// Save context map if configured
	if e.Ctx.MapFile != "" {
		if err := e.Ctx.SaveMap(); err != nil {
			return fmt.Errorf("failed to save context map: %w", err)
		}
		fmt.Printf("📋 Context map saved: %s\n", e.Ctx.MapFile)
	}

	return nil
}

// GetPassByName returns a pass by its name
func (e *Engine) GetPassByName(name string) TranspilePass {
	for _, pass := range e.Passes {
		if pass.Name() == name {
			return pass
		}
	}
	return nil
}

// ListPasses returns the names of all registered passes
func (e *Engine) ListPasses() []string {
	names := make([]string, len(e.Passes))
	for i, pass := range e.Passes {
		names[i] = pass.Name()
	}
	return names
}

/// engine/generator.go ///
// Package transpiler implementa geração de código bitwise otimizado
package transpiler

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"strings"
)

// BitwiseCodeGenerator gera código Go otimizado com operações bitwise
type BitwiseCodeGenerator struct {
	fset *token.FileSet
}

// NewBitwiseCodeGenerator cria um novo gerador de código bitwise
func NewBitwiseCodeGenerator() *BitwiseCodeGenerator {
	return &BitwiseCodeGenerator{
		fset: token.NewFileSet(),
	}
}

// GenerateBitwiseCode gera código bitwise otimizado a partir de um arquivo Go tradicional
func (bcg *BitwiseCodeGenerator) GenerateBitwiseCode(filename string) (string, error) {
	node, err := parser.ParseFile(bcg.fset, filename, nil, parser.ParseComments)
	if err != nil {
		return "", fmt.Errorf("erro ao parsear arquivo: %w", err)
	}

	var output strings.Builder

	// Header do arquivo gerado
	output.WriteString("// Generated by GASType Bitwise Transpiler\n")
	output.WriteString("// Original file: " + filename + "\n")
	output.WriteString("// ULTRA-OPTIMIZED BITWISE CODE - DO NOT EDIT MANUALLY!\n\n")

	output.WriteString("package main\n\n")
	output.WriteString("import (\n\t\"fmt\"\n)\n\n")

	// Gerar definições de flags bitwise
	output.WriteString(bcg.generateBitwiseDefinitions(node))

	// Gerar funções utilitárias bitwise
	output.WriteString(bcg.generateBitwiseUtilities())

	// Gerar código principal transpilado
	output.WriteString(bcg.generateTranspiledMain(node))

	return output.String(), nil
}

// generateBitwiseDefinitions gera as definições de flags bitwise para structs
func (bcg *BitwiseCodeGenerator) generateBitwiseDefinitions(node *ast.File) string {
	var output strings.Builder

	ast.Inspect(node, func(n ast.Node) bool {
		if typeSpec, ok := n.(*ast.TypeSpec); ok {
			if structType, ok := typeSpec.Type.(*ast.StructType); ok {
				bitwiseCode := bcg.convertStructToBitwise(typeSpec.Name.Name, structType)
				if bitwiseCode != "" {
					output.WriteString(bitwiseCode)
					output.WriteString("\n")
				}
			}
		}
		return true
	})

	return output.String()
}

// convertStructToBitwise converte uma struct com campos bool para sistema de flags bitwise
func (bcg *BitwiseCodeGenerator) convertStructToBitwise(structName string, structType *ast.StructType) string {
	var boolFields []string
	var otherFields []string

	// Separar campos bool dos demais
	for _, field := range structType.Fields.List {
		if ident, ok := field.Type.(*ast.Ident); ok && ident.Name == "bool" {
			for _, name := range field.Names {
				boolFields = append(boolFields, name.Name)
			}
		} else {
			// Campos não-bool mantidos como estão
			for _, name := range field.Names {
				fieldType := ""
				if ident, ok := field.Type.(*ast.Ident); ok {
					fieldType = ident.Name
				}
				otherFields = append(otherFields, fmt.Sprintf("\t%s %s", name.Name, fieldType))
			}
		}
	}

	if len(boolFields) == 0 {
		return ""
	}

	var output strings.Builder

	// Gerar tipo de flags
	flagTypeName := structName + "Flags"
	output.WriteString(fmt.Sprintf("// %s represents bitwise flags for %s\n", flagTypeName, structName))
	output.WriteString(fmt.Sprintf("type %s uint64\n\n", flagTypeName))

	// Gerar constantes de flags
	output.WriteString(fmt.Sprintf("// %s flag constants\n", structName))
	output.WriteString("const (\n")
	for i, field := range boolFields {
		if i == 0 {
			output.WriteString(fmt.Sprintf("\tFlag%s_%s %s = 1 << iota\n", structName, field, flagTypeName))
		} else {
			output.WriteString(fmt.Sprintf("\tFlag%s_%s\n", structName, field))
		}
	}
	output.WriteString(")\n\n")

	// Gerar struct bitwise otimizada
	output.WriteString(fmt.Sprintf("// %sBitwise is the bitwise-optimized version of %s\n", structName, structName))
	output.WriteString(fmt.Sprintf("type %sBitwise struct {\n", structName))
	output.WriteString(fmt.Sprintf("\tFlags %s `json:\"flags\"`\n", flagTypeName))

	// Adicionar campos não-bool se existirem
	for _, field := range otherFields {
		output.WriteString(field + "\n")
	}

	output.WriteString("}\n\n")

	// Gerar métodos utilitários
	output.WriteString(bcg.generateFlagMethods(structName, flagTypeName, boolFields))

	return output.String()
}

// generateFlagMethods gera métodos para manipulação de flags
func (bcg *BitwiseCodeGenerator) generateFlagMethods(structName, flagTypeName string, fields []string) string {
	var output strings.Builder
	bitwiseStructName := structName + "Bitwise"

	// Método para setar flag
	output.WriteString(fmt.Sprintf("// Set%sFlag sets a specific flag\n", structName))
	output.WriteString(fmt.Sprintf("func (c *%s) Set%sFlag(flag %s) {\n", bitwiseStructName, structName, flagTypeName))
	output.WriteString("\tc.Flags |= flag\n")
	output.WriteString("}\n\n")

	// Método para limpar flag
	output.WriteString(fmt.Sprintf("// Clear%sFlag clears a specific flag\n", structName))
	output.WriteString(fmt.Sprintf("func (c *%s) Clear%sFlag(flag %s) {\n", bitwiseStructName, structName, flagTypeName))
	output.WriteString("\tc.Flags &^= flag\n")
	output.WriteString("}\n\n")

	// Método para verificar flag
	output.WriteString(fmt.Sprintf("// Has%sFlag checks if a specific flag is set\n", structName))
	output.WriteString(fmt.Sprintf("func (c *%s) Has%sFlag(flag %s) bool {\n", bitwiseStructName, structName, flagTypeName))
	output.WriteString("\treturn c.Flags&flag != 0\n")
	output.WriteString("}\n\n")

	// Gerar métodos específicos para cada campo bool
	for _, field := range fields {
		// Getter
		output.WriteString(fmt.Sprintf("// %s returns the state of %s flag\n", field, field))
		output.WriteString(fmt.Sprintf("func (c *%s) %s() bool {\n", bitwiseStructName, field))
		output.WriteString(fmt.Sprintf("\treturn c.Has%sFlag(Flag%s_%s)\n", structName, structName, field))
		output.WriteString("}\n\n")

		// Setter
		output.WriteString(fmt.Sprintf("// Set%s sets the %s flag\n", field, field))
		output.WriteString(fmt.Sprintf("func (c *%s) Set%s(enabled bool) {\n", bitwiseStructName, field))
		output.WriteString("\tif enabled {\n")
		output.WriteString(fmt.Sprintf("\t\tc.Set%sFlag(Flag%s_%s)\n", structName, structName, field))
		output.WriteString("\t} else {\n")
		output.WriteString(fmt.Sprintf("\t\tc.Clear%sFlag(Flag%s_%s)\n", structName, structName, field))
		output.WriteString("\t}\n")
		output.WriteString("}\n\n")
	}

	return output.String()
}

// generateBitwiseUtilities gera funções utilitárias para operações bitwise
func (bcg *BitwiseCodeGenerator) generateBitwiseUtilities() string {
	return `// Bitwise utility functions for performance optimization

// PopCount counts the number of set bits (performance critical)
func PopCount(x uint64) int {
	count := 0
	for x != 0 {
		count++
		x &= x - 1 // Clear lowest set bit
	}
	return count
}

// HasAnyFlags checks if any of the specified flags are set (ultra-fast)
func HasAnyFlags(value, mask uint64) bool {
	return value&mask != 0
}

// HasAllFlags checks if all specified flags are set (ultra-fast)
func HasAllFlags(value, mask uint64) bool {
	return value&mask == mask
}

// ToggleFlags toggles specified flags (XOR operation)
func ToggleFlags(value, mask uint64) uint64 {
	return value ^ mask
}

`
}

// generateTranspiledMain gera a função main transpilada
func (bcg *BitwiseCodeGenerator) generateTranspiledMain(node *ast.File) string {
	var output strings.Builder

	output.WriteString("// Transpiled main function with bitwise optimizations\n")
	output.WriteString("func main() {\n")
	output.WriteString("\tfmt.Println(\"🚀 GASType Bitwise-Optimized Code Running!\")\n\n")

	// Exemplo de uso do código bitwise
	output.WriteString("\t// Create bitwise-optimized Discord config\n")
	output.WriteString("\tconfig := &DiscordConfigBitwise{}\n")
	output.WriteString("\tconfig.SetEnableBot(true)\n")
	output.WriteString("\tconfig.SetEnableCommands(true)\n")
	output.WriteString("\tconfig.SetEnableLogging(true)\n\n")

	output.WriteString("\t// Ultra-fast bitwise logic (replaces slow if/else chains)\n")
	output.WriteString("\tbotAndCommands := FlagDiscordConfig_EnableBot | FlagDiscordConfig_EnableCommands\n")
	output.WriteString("\tif HasAllFlags(uint64(config.Flags), uint64(botAndCommands)) {\n")
	output.WriteString("\t\tfmt.Println(\"✅ Bot with commands enabled (BITWISE OPTIMIZED!)\")\n")
	output.WriteString("\t}\n\n")

	output.WriteString("\tbotAndLogging := FlagDiscordConfig_EnableBot | FlagDiscordConfig_EnableLogging\n")
	output.WriteString("\tif HasAllFlags(uint64(config.Flags), uint64(botAndLogging)) {\n")
	output.WriteString("\t\tfmt.Println(\"✅ Bot with logging enabled (BITWISE OPTIMIZED!)\")\n")
	output.WriteString("\t}\n\n")

	// Performance demonstration
	output.WriteString("\t// Performance demonstration\n")
	output.WriteString("\tfmt.Printf(\"🔥 Active flags count: %d\\n\", PopCount(uint64(config.Flags)))\n")
	output.WriteString("\tfmt.Printf(\"⚡ Config flags: %064b\\n\", config.Flags)\n")

	output.WriteString("}\n")

	return output.String()
}

/// engine/pipeline.go ///
// Package transpiler provides pipeline functionality for coordinating multiple transpilation passes
package transpiler

import (
	"strings"

	"github.com/rafa-mori/gastype/internal/pass"
)

// DefaultPipeline creates a pipeline with the specified passes
func DefaultPipeline(passes string) []TranspilePass {
	var selected []TranspilePass

	for _, p := range strings.Split(passes, ",") {
		switch strings.TrimSpace(p) {
		case "bool2flags", "bool-to-flags":
			selected = append(selected, pass.NewBoolToFlagsPass())
		case "if2bitwise", "if-to-bitwise":
			selected = append(selected, pass.NewIfToBitwisePass())
		case "assign2bitwise", "assign-to-bitwise":
			selected = append(selected, pass.NewAssignToBitwisePass())
		case "field2bitwise", "field-to-bitwise":
			selected = append(selected, pass.NewFieldAccessToBitwisePass())
		case "stringobf", "string-obfuscate":
			selected = append(selected, pass.NewStringObfuscatePass())
		case "jumptable", "jump-table":
			selected = append(selected, pass.NewJumpTablePass())
		}
	}

	return selected
}

// RevolutionPipeline returns all available passes for maximum transformation
func RevolutionPipeline() []TranspilePass {
	return []TranspilePass{
		pass.NewBoolToFlagsPass(),          // Convert bool fields to bitwise flags
		pass.NewIfToBitwisePass(),          // Convert bool conditions to bitwise checks
		pass.NewAssignToBitwisePass(),      // Convert bool assignments to bitwise operations
		pass.NewFieldAccessToBitwisePass(), // 🚀 REVOLUTIONARY: Convert field access to bitwise checks
		pass.NewStringObfuscatePass(),      // Obfuscate string literals
		pass.NewJumpTablePass(),            // Optimize if-chains to jump tables
	}
}

// GetAvailablePasses returns a list of all available pass names
func GetAvailablePasses() []string {
	return []string{
		"bool2flags",
		"if2bitwise",
		"assign2bitwise",
		"field2bitwise",
		"stringobf",
		"jumptable",
	}
}

/// engine/real_transpiler.go ///
// Package transpiler provides real bitwise transpilation functionality
package transpiler

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"os"

	"github.com/rafa-mori/gastype/internal/astutil"
)

// RealBitwiseTranspiler performs actual code transformation
type RealBitwiseTranspiler struct {
	fset    *token.FileSet
	context *astutil.TranspileContext
}

// NewRealBitwiseTranspiler creates a new real transpiler
func NewRealBitwiseTranspiler() *RealBitwiseTranspiler {
	return &RealBitwiseTranspiler{
		fset: token.NewFileSet(),
	}
}

// NewRealBitwiseTranspilerWithContext creates a new real transpiler with context
func NewRealBitwiseTranspilerWithContext(ctx *astutil.TranspileContext) *RealBitwiseTranspiler {
	return &RealBitwiseTranspiler{
		fset:    token.NewFileSet(),
		context: ctx,
	}
}

// TranspileBoolToFlags converts bool struct fields to bitwise flags
func (t *RealBitwiseTranspiler) TranspileBoolToFlags(inputFile, outputFile string) error {
	// Create default context if none provided
	if t.context == nil {
		t.context = astutil.NewContext(inputFile, outputFile, false, "")
	}

	fmt.Printf("🔄 Transpiling %s → %s\n", inputFile, outputFile)

	// Parse the input file
	f, err := parser.ParseFile(t.fset, inputFile, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("failed to parse file: %w", err)
	}

	// Track structs that need flag constants
	structsToTransform := make(map[string][]string) // struct name -> field names

	// Step 1: Find structs with bool fields
	ast.Inspect(f, func(n ast.Node) bool {
		ts, ok := n.(*ast.TypeSpec)
		if !ok {
			return true
		}
		st, ok := ts.Type.(*ast.StructType)
		if !ok {
			return true
		}

		var boolFields []string
		for _, field := range st.Fields.List {
			if ident, ok := field.Type.(*ast.Ident); ok && ident.Name == "bool" {
				for _, name := range field.Names {
					boolFields = append(boolFields, name.Name)
				}
			}
		}

		if len(boolFields) > 0 {
			originalName := ts.Name.Name
			newName := originalName + "Flags"

			fmt.Printf("  📝 Converting struct %s → %s (%d bool fields)\n",
				originalName, newName, len(boolFields))

			// Register in context
			packageName := f.Name.Name
			t.context.AddStruct(packageName, originalName, newName, boolFields)

			structsToTransform[originalName] = boolFields

			// Transform struct to use flags field instead of bool fields
			ts.Name.Name = newName

			// Replace struct fields with single flags field
			st.Fields.List = []*ast.Field{
				{
					Names: []*ast.Ident{{Name: "flags"}},
					Type:  &ast.Ident{Name: "uint64"},
				},
			}
		}
		return true
	})

	// Step 2: Add flag constants for each transformed struct
	if len(structsToTransform) > 0 {
		t.addFlagConstants(f, structsToTransform)
	}

	// Step 3: Transform struct literals and field access
	t.transformStructUsage(f, structsToTransform)

	// Step 4: Write the transformed code
	out, err := os.Create(outputFile)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer out.Close()

	if err := printer.Fprint(out, t.fset, f); err != nil {
		return fmt.Errorf("failed to write transformed code: %w", err)
	}

	// Step 5: Save context map if configured
	if t.context.MapFile != "" {
		if err := t.context.SaveMap(); err != nil {
			fmt.Printf("  ⚠️  Warning: Failed to save context map: %v\n", err)
		} else {
			fmt.Printf("  📋 Context map saved: %s\n", t.context.MapFile)
		}
	}

	fmt.Printf("  ✅ Transpilation complete: %s\n", outputFile)
	return nil
}

// addFlagConstants adds const declarations for bitwise flags
func (t *RealBitwiseTranspiler) addFlagConstants(f *ast.File, structs map[string][]string) {
	for _, fields := range structs {
		// Create const group for this struct
		specs := []ast.Spec{}

		for i, field := range fields {
			constName := "Flag" + field

			spec := &ast.ValueSpec{
				Names: []*ast.Ident{{Name: constName}},
				Type:  &ast.Ident{Name: "uint64"},
			}

			// All flags need explicit bit shift values
			spec.Values = []ast.Expr{
				&ast.BinaryExpr{
					X: &ast.BasicLit{
						Kind:  token.INT,
						Value: "1",
					},
					Op: token.SHL,
					Y: &ast.BasicLit{
						Kind:  token.INT,
						Value: fmt.Sprintf("%d", i),
					},
				},
			}

			specs = append(specs, spec)
		} // Create the const declaration
		constDecl := &ast.GenDecl{
			Tok:   token.CONST,
			Specs: specs,
		}

		// Insert const declaration after imports
		insertPos := 0
		for i, decl := range f.Decls {
			if genDecl, ok := decl.(*ast.GenDecl); ok && genDecl.Tok == token.IMPORT {
				insertPos = i + 1
			}
		}

		// Insert the const declaration
		newDecls := make([]ast.Decl, 0, len(f.Decls)+1)
		newDecls = append(newDecls, f.Decls[:insertPos]...)
		newDecls = append(newDecls, constDecl)
		newDecls = append(newDecls, f.Decls[insertPos:]...)
		f.Decls = newDecls

		fmt.Printf("    🏷️  Added constants: %v\n", astutil.GetConstNames(fields))
	}
}

// transformStructUsage transforms struct literals and field access
func (t *RealBitwiseTranspiler) transformStructUsage(f *ast.File, structs map[string][]string) {
	packageName := f.Name.Name

	ast.Inspect(f, func(n ast.Node) bool {
		switch node := n.(type) {
		case *ast.CompositeLit:
			// Transform struct literals like ServiceConfig{Debug: true, Auth: false}
			if ident, ok := node.Type.(*ast.Ident); ok {
				if fields, exists := structs[ident.Name]; exists {
					t.transformCompositeLit(node, ident.Name, fields)
				}
			}
		case *ast.SelectorExpr:
			// Transform field access like cfg.Debug
			t.transformFieldAccess(node, structs)
		case *ast.IfStmt:
			// Transform if conditions like if cfg.Debug
			t.transformIfCondition(node, structs)
		case *ast.AssignStmt:
			// Transform assignments like cfg.Debug = true
			t.transformAssignment(node, packageName, structs)
		}
		return true
	})
}

// transformCompositeLit transforms struct literal initialization
func (t *RealBitwiseTranspiler) transformCompositeLit(node *ast.CompositeLit, structName string, fields []string) {
	// Change type to FlagsType
	node.Type = &ast.Ident{Name: structName + "Flags"}

	// Store original field initializations for later transformation
	originalInits := make(map[string]bool)

	fmt.Printf("      🔍 Analyzing composite literal with %d elements\n", len(node.Elts))

	// Extract field initializations
	for i, elt := range node.Elts {
		fmt.Printf("      🔍 Element %d: %T\n", i, elt)
		if kv, ok := elt.(*ast.KeyValueExpr); ok {
			fmt.Printf("      🔍 KeyValue found\n")
			if key, ok := kv.Key.(*ast.Ident); ok {
				fmt.Printf("      🔍 Key: %s\n", key.Name)
				if val, ok := kv.Value.(*ast.Ident); ok {
					fmt.Printf("      🔍 Value: %s\n", val.Name)
					originalInits[key.Name] = (val.Name == "true")
				}
			}
		}
	}

	// Clear elements - we'll use assignments after the literal
	node.Elts = nil

	// TODO: Generate assignment statements after the variable declaration
	// This is complex and would require AST rewriting at statement level
	// For now, we'll note what needs to be initialized
	fmt.Printf("    🔄 Transformed struct literal for %s\n", structName)
	for field, value := range originalInits {
		fmt.Printf("      📋 Field %s was %t\n", field, value)
	}
} // transformFieldAccess transforms field access to bitwise operations
func (t *RealBitwiseTranspiler) transformFieldAccess(node *ast.SelectorExpr, structs map[string][]string) {
	// Look for patterns like cfg.Debug where cfg is a flags type
	if ident, ok := node.X.(*ast.Ident); ok {
		fieldName := node.Sel.Name

		// Check if this could be a flag field access
		for _, fields := range structs {
			for _, field := range fields {
				if field == fieldName {
					// This might be a flag access - we'll transform in context
					fmt.Printf("    🎯 Found field access: %s.%s\n", ident.Name, fieldName)
				}
			}
		}
	}
}

// transformIfCondition transforms if conditions to use bitwise checks
func (t *RealBitwiseTranspiler) transformIfCondition(node *ast.IfStmt, structs map[string][]string) {
	// Look for conditions like "if cfg.Debug"
	if sel, ok := node.Cond.(*ast.SelectorExpr); ok {
		if ident, ok := sel.X.(*ast.Ident); ok {
			fieldName := sel.Sel.Name

			// Check if this is a flag field
			for _, fields := range structs {
				for _, field := range fields {
					if field == fieldName {
						// Transform to bitwise check: cfg.flags & FlagDebug != 0
						flagName := "Flag" + fieldName

						node.Cond = &ast.BinaryExpr{
							X: &ast.BinaryExpr{
								X: &ast.SelectorExpr{
									X:   &ast.Ident{Name: ident.Name},
									Sel: &ast.Ident{Name: "flags"},
								},
								Op: token.AND,
								Y:  &ast.Ident{Name: flagName},
							},
							Op: token.NEQ,
							Y: &ast.BasicLit{
								Kind:  token.INT,
								Value: "0",
							},
						}

						fmt.Printf("    ⚡ Transformed if condition: %s.%s → bitwise check\n", ident.Name, fieldName)
						return
					}
				}
			}
		}
	}
}

// transformAssignment transforms assignments like cfg.Debug = true/false
func (t *RealBitwiseTranspiler) transformAssignment(node *ast.AssignStmt, packageName string, structs map[string][]string) {
	if len(node.Lhs) != 1 || len(node.Rhs) != 1 {
		return
	}

	// Check if left side is a selector expression (e.g., cfg.Debug)
	sel, ok := node.Lhs[0].(*ast.SelectorExpr)
	if !ok {
		return
	}

	val, ok := node.Rhs[0].(*ast.Ident)
	if !ok {
		return
	}

	fieldName := sel.Sel.Name

	// Check if this is a bool field assignment using context
	for structName := range t.context.Structs {
		if t.context.IsBoolField(structName, fieldName) {
			flagName := t.context.GetFlagName(packageName, structName, fieldName)

			if val.Name == "true" {
				// Transform to: obj.flags |= FlagField
				node.Lhs[0] = &ast.SelectorExpr{
					X:   sel.X,
					Sel: &ast.Ident{Name: "flags"},
				}
				node.Tok = token.OR_ASSIGN
				node.Rhs[0] = &ast.Ident{Name: flagName}

				fmt.Printf("    ⚡ Transformed assignment: %s = true → flags |= %s\n", fieldName, flagName)
			} else if val.Name == "false" {
				// Transform to: obj.flags &^= FlagField
				node.Lhs[0] = &ast.SelectorExpr{
					X:   sel.X,
					Sel: &ast.Ident{Name: "flags"},
				}
				node.Tok = token.AND_NOT_ASSIGN
				node.Rhs[0] = &ast.Ident{Name: flagName}

				fmt.Printf("    ⚡ Transformed assignment: %s = false → flags &^= %s\n", fieldName, flagName)
			}
			return
		}
	}
}

// TranspileFile transpiles a single file using the real transpiler
func (t *RealBitwiseTranspiler) TranspileFile(inputPath, outputPath string) error {
	return t.TranspileBoolToFlags(inputPath, outputPath)
}

// TranspileProject transpiles an entire project
func (t *RealBitwiseTranspiler) TranspileProject(inputDir, outputDir string) error {
	fmt.Printf("🚀 Starting real project transpilation: %s → %s\n", inputDir, outputDir)

	// For now, just show what we would do
	fmt.Printf("  📁 Would recursively transpile all .go files\n")
	fmt.Printf("  ⚡ Would apply bool→bitflags transformation\n")
	fmt.Printf("  🔄 Would preserve non-transpilable code\n")

	return nil
}

/// engine/transpiler.go ///
// Package transpiler implementa pipeline de transpilação e sugestões bitwise
package transpiler

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
)

// StructBitwiseSuggestion representa sugestão de conversão de campos bool para flags
type StructBitwiseSuggestion struct {
	StructName string
	BoolFields []string
	File       string
	Line       int
}

// BitwiseTranspiler é a estrutura principal para transpilação bitwise
type BitwiseTranspiler struct {
	fset *token.FileSet
}

// NewBitwiseTranspiler cria um novo transpiler bitwise
func NewBitwiseTranspiler() *BitwiseTranspiler {
	return &BitwiseTranspiler{
		fset: token.NewFileSet(),
	}
}

// TranspilationResult representa o resultado de uma análise/transpilação
type TranspilationResult struct {
	OriginalFile     string            `json:"original_file"`
	TranspiledFile   string            `json:"transpiled_file"`
	Optimizations    []Optimization    `json:"optimizations"`
	SecurityFeatures []SecurityFeature `json:"security_features"`
}

// Optimization representa uma otimização encontrada
type Optimization struct {
	Type          string  `json:"type"`
	Description   string  `json:"description"`
	Location      string  `json:"location"`
	BytesSaved    int     `json:"bytes_saved"`
	SpeedupFactor float64 `json:"speedup_factor"`
}

// SecurityFeature representa um recurso de segurança aplicado
type SecurityFeature struct {
	Description string `json:"description"`
	Strength    string `json:"strength"`
}

// AnalyzeFile analisa um arquivo único e retorna resultados de otimização
func (bt *BitwiseTranspiler) AnalyzeFile(filename string) (*TranspilationResult, error) {
	suggestions, err := bt.analyzeFileSugereBitwise(filename)
	if err != nil {
		return nil, fmt.Errorf("erro na análise bitwise: %w", err)
	}

	result := &TranspilationResult{
		OriginalFile:     filename,
		TranspiledFile:   strings.Replace(filename, ".go", "_bitwise.go", 1),
		Optimizations:    []Optimization{},
		SecurityFeatures: []SecurityFeature{},
	}

	// Converter sugestões em otimizações
	for _, s := range suggestions {
		opt := Optimization{
			Type:          "BitfieldConversion",
			Description:   fmt.Sprintf("Convert %d bool fields to bitwise flags in struct %s", len(s.BoolFields), s.StructName),
			Location:      fmt.Sprintf("%s:%d", s.File, s.Line),
			BytesSaved:    len(s.BoolFields) * 7, // 8 bytes -> 1 byte per bool
			SpeedupFactor: 2.5,                   // Estimativa conservadora
		}
		result.Optimizations = append(result.Optimizations, opt)

		// Adicionar recurso de segurança
		security := SecurityFeature{
			Description: fmt.Sprintf("Obfuscated struct %s with bitwise operations", s.StructName),
			Strength:    "Medium",
		}
		result.SecurityFeatures = append(result.SecurityFeatures, security)
	}

	return result, nil
}

// AnalyzeProject analisa um projeto inteiro (diretório)
func (bt *BitwiseTranspiler) AnalyzeProject(projectDir string) ([]TranspilationResult, error) {
	var results []TranspilationResult

	err := filepath.Walk(projectDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Analisar apenas arquivos .go
		if !strings.HasSuffix(path, ".go") {
			return nil
		}

		result, err := bt.AnalyzeFile(path)
		if err != nil {
			return fmt.Errorf("erro analisando %s: %w", path, err)
		}

		// Apenas adicionar se há otimizações
		if len(result.Optimizations) > 0 {
			results = append(results, *result)
		}

		return nil
	})

	if err != nil {
		return nil, fmt.Errorf("erro percorrendo projeto: %w", err)
	}

	return results, nil
}

// analyzeFileSugereBitwise analisa um arquivo Go e retorna structs que podem ser convertidos para bitwise
func (bt *BitwiseTranspiler) analyzeFileSugereBitwise(filename string) ([]StructBitwiseSuggestion, error) {
	file, err := os.Open(filename)
	if err != nil {
		return nil, fmt.Errorf("erro ao abrir arquivo: %w", err)
	}
	defer file.Close()

	node, err := parser.ParseFile(bt.fset, filename, nil, parser.AllErrors)
	if err != nil {
		return nil, fmt.Errorf("erro ao parsear arquivo: %w", err)
	}

	var suggestions []StructBitwiseSuggestion

	ast.Inspect(node, func(n ast.Node) bool {
		st, ok := n.(*ast.TypeSpec)
		if !ok {
			return true
		}
		structType, ok := st.Type.(*ast.StructType)
		if !ok {
			return true
		}
		var boolFields []string
		for _, field := range structType.Fields.List {
			if ident, ok := field.Type.(*ast.Ident); ok && ident.Name == "bool" {
				for _, name := range field.Names {
					boolFields = append(boolFields, name.Name)
				}
			}
		}
		if len(boolFields) > 0 {
			pos := bt.fset.Position(st.Pos())
			suggestions = append(suggestions, StructBitwiseSuggestion{
				StructName: st.Name.Name,
				BoolFields: boolFields,
				File:       pos.Filename,
				Line:       pos.Line,
			})
		}
		return true
	})
	return suggestions, nil
}

// GenerateTranspiledCode gera código bitwise otimizado para um arquivo
func (bt *BitwiseTranspiler) GenerateTranspiledCode(filename string) (string, error) {
	generator := NewBitwiseCodeGenerator()
	return generator.GenerateBitwiseCode(filename)
}

// SugereBitwiseParaArquivo executa análise e imprime sugestões para conversão bitwise
func SugereBitwiseParaArquivo(filename string) error {
	bt := NewBitwiseTranspiler()
	suggestions, err := bt.analyzeFileSugereBitwise(filename)
	if err != nil {
		return fmt.Errorf("erro na análise bitwise: %w", err)
	}
	if len(suggestions) == 0 {
		fmt.Printf("Nenhuma struct com campos bool encontrada em %s\n", filename)
		return nil
	}
	fmt.Printf("\n--- SUGESTÃO DE CONVERSÃO BITWISE ---\n")
	for _, s := range suggestions {
		fmt.Printf("Arquivo: %s (linha %d)\nStruct: %s\nCampos bool: %v\nSugestão: Converter para uint64 Flags (bitwise)\n\n", s.File, s.Line, s.StructName, s.BoolFields)
	}
	return nil
}

/// globals/environment.go ///
package globals

import (
	"fmt"
	"os"
	"runtime"
	"syscall"

	l "github.com/faelmori/logz"
	t "github.com/rafa-mori/gastype/interfaces"
)

type Environment struct {
	cpuCount int
	memTotal int
	hostname string
	os       string
	kernel   string
}

func NewEnvironment() t.IEnvironment { return &Environment{} }

func (e *Environment) CPUCount() int {
	if e.cpuCount == 0 {
		e.cpuCount = runtime.NumCPU()
	}
	return e.cpuCount
}

func (e *Environment) MemTotal() int {
	if e.memTotal == 0 {
		var mem syscall.Sysinfo_t
		err := syscall.Sysinfo(&mem)
		if err != nil {
			l.Error(fmt.Sprintf("Error getting memory info: %s", err.Error()), nil)
			return 0
		}
		totalRAM := mem.Totalram * uint64(mem.Unit) / (1024 * 1024) // Convertendo para MB
		e.memTotal = int(totalRAM)
	}
	return e.memTotal
}

func (e *Environment) Hostname() string {
	if e.hostname == "" {
		hostname, err := os.Hostname()
		if err != nil {
			l.Error(fmt.Sprintf("Error getting hostname: %s", err.Error()), nil)
			return ""
		}
		e.hostname = hostname
	}
	return e.hostname
}

func (e *Environment) OS() string {
	if e.os == "" {
		e.os = runtime.GOOS
	}
	return e.os
}

func (e *Environment) Kernel() string {
	if e.kernel == "" {
		e.kernel = runtime.GOARCH
	}
	return e.kernel
}

/// globals/result.go ///
// Package globals provides a Result struct that encapsulates the result of a type check operation.
package globals

import (
	"fmt"

	l "github.com/faelmori/logz"
	t "github.com/rafa-mori/gastype/interfaces"
)

type Result struct {
	Package string `json:"package"`         // Name of the package
	Status  string `json:"status"`          // Status of the type check (Success, Failed, Error)
	Error   string `json:"error,omitempty"` // Error message if any
}

func NewResult(pkg, status string, err error) t.IResult {
	errorStr := ""

	if err != nil {
		l.Error(fmt.Sprintf("[ %s ] %s", pkg, err.Error()), map[string]interface{}{})
		errorStr = err.Error()
	}

	return &Result{
		Package: pkg,
		Status:  status,
		Error:   errorStr,
	}
}

func (c *Result) GetPackage() string { return c.Package }
func (c *Result) GetStatus() string  { return c.Status }
func (c *Result) GetError() string   { return c.Error }

func (c *Result) SetPackage(packageName string) { c.Package = packageName }
func (c *Result) SetStatus(status string)       { c.Status = status }
func (c *Result) SetError(err string)           { c.Error = err }

func (c *Result) ToJSON(outputTarget string) string {
	return ""
}
func (c *Result) ToXML(outputTarget string) string {
	return ""
}
func (c *Result) ToCSV(outputTarget string) string {
	return ""
}
func (c *Result) ToMap() map[string]interface{} {
	return nil
}

func (c *Result) DataTable() error {
	return nil
}

/// manager/type_manager.go ///
package manager

import (
	"fmt"
	"sync"

	"github.com/rafa-mori/gastype/internal/actions"
	"github.com/rafa-mori/gastype/utils"

	l "github.com/faelmori/logz"
	t "github.com/rafa-mori/gastype/interfaces"
)

// TypeManager manages type-related actions and notifications
type TypeManager struct {
	notifierChan chan string
	email        string
	emailToken   string
	notify       bool
	cfg          t.IConfig
	actions      []t.IAction
	isRunning    bool
	mu           sync.Mutex
}

// NewTypeManager creates a new instance of TypeManager
func NewTypeManager(cfg t.IConfig) t.ITypeManager {
	return &TypeManager{
		cfg:          cfg,
		notifierChan: make(chan string),
		actions:      []t.IAction{},
		isRunning:    false,
	}
}

// Getters
func (tm *TypeManager) GetNotifierChan() chan string { return tm.notifierChan }
func (tm *TypeManager) GetEmail() string             { return tm.email }
func (tm *TypeManager) GetEmailToken() string        { return tm.emailToken }
func (tm *TypeManager) GetNotify() bool              { return tm.notify }
func (tm *TypeManager) GetConfig() t.IConfig         { return tm.cfg }
func (tm *TypeManager) GetActions() []t.IAction      { return tm.actions }
func (tm *TypeManager) IsRunning() bool              { return tm.isRunning }

// Setters
func (tm *TypeManager) SetNotifierChan(notifierChan chan string) { tm.notifierChan = notifierChan }
func (tm *TypeManager) SetEmail(email string)                    { tm.email = email }
func (tm *TypeManager) SetEmailToken(emailToken string)          { tm.emailToken = emailToken }
func (tm *TypeManager) SetNotify(notify bool)                    { tm.notify = notify }
func (tm *TypeManager) SetConfig(cfg t.IConfig)                  { tm.cfg = cfg }
func (tm *TypeManager) AddAction(action t.IAction)               { tm.actions = append(tm.actions, action) }

// StartChecking begins the process of checking Go files
func (tm *TypeManager) StartChecking(workerCount int) error {
	if len(tm.actions) == 0 {
		return fmt.Errorf("no actions available to execute")
	}

	//tm.mu.Lock()
	//defer tm.mu.Unlock()

	if tm.isRunning {
		return fmt.Errorf("manager is already running")
	}

	workerManager := NewWorkerManager(workerCount)
	for _, action := range tm.actions {
		if action.CanExecute() {
			workerManager.GetJobQueue() <- action
		} else {
			l.Warn(fmt.Sprintf("Action %s cannot execute", action.GetType()), nil)
		}
	}

	go workerManager.StartWorkers()
	tm.isRunning = true
	return nil
}
func (tm *TypeManager) StopChecking() {
	//tm.mu.Lock()
	//defer tm.mu.Unlock()

	if !tm.isRunning {
		l.Warn("manager is not running", nil)
		return
	}

	close(tm.notifierChan)
	tm.isRunning = false
	l.Info("TypeManager stopped successfully", nil)
}
func (tm *TypeManager) LoadConfig() error {
	if tm.cfg == nil {
		return fmt.Errorf("configuration not initialized")
	}
	return tm.cfg.Load()
}
func (tm *TypeManager) SaveConfig() error {
	if tm.cfg == nil {
		return fmt.Errorf("configuration not initialized")
	}
	return nil // Implement saving logic here
}
func (tm *TypeManager) CanNotify() bool {
	return tm.notify && tm.notifierChan != nil
}
func (tm *TypeManager) PrepareActions() error {
	parsedFiles, err := utils.ParseFiles(tm.cfg.GetDir())
	if err != nil {
		return fmt.Errorf("error parsing files: %v", err)
	}
	// Criar ações baseadas nos arquivos analisados.
	for pkgName, files := range parsedFiles {
		action := actions.NewTypeCheckAction(pkgName, files, tm.cfg)
		tm.AddAction(action)
	}
	return nil
}

/// manager/worker_manager.go ///
package manager

import (
	"sync"

	l "github.com/faelmori/logz"
	t "github.com/rafa-mori/gastype/interfaces"
)

// WorkerManager manages the pool of workers for parallel task execution
type WorkerManager struct {
	WorkerCount int
	JobQueue    chan t.IAction
	Results     chan t.IResult
	StopChannel chan struct{}
	mu          sync.Mutex
}

// NewWorkerManager creates a new instance of WorkerManager
func NewWorkerManager(workerCount int) t.IWorker {
	return &WorkerManager{
		WorkerCount: workerCount,
		JobQueue:    make(chan t.IAction, workerCount),
		Results:     make(chan t.IResult, workerCount),
		StopChannel: make(chan struct{}),
	}
}

// StartWorkers starts the pool of workers
func (wm *WorkerManager) StartWorkers() {
	var wg sync.WaitGroup

	for i := 0; i < wm.WorkerCount; i++ {
		wg.Add(1)
		go func(workerID int) {
			defer wg.Done()
			l.Info("Worker started", map[string]interface{}{
				"worker_id": workerID,
			})

			for {
				select {
				case <-wm.StopChannel:
					l.Info("Worker stopped", map[string]interface{}{
						"worker_id": workerID,
					})
					return
				case job, ok := <-wm.JobQueue:
					if !ok {
						return
					}
					if err := job.Execute(); err != nil {
						l.Error("Error executing job", map[string]interface{}{
							"error": err.Error(),
							"job":   job.GetType(),
						})
					}
				}
			}
		}(i)
	}

	wg.Wait()
}

// StopWorkers stops all workers gracefully
func (wm *WorkerManager) StopWorkers() {
	close(wm.StopChannel)
	close(wm.JobQueue)
}

// GetJobQueue returns the job queue channel
func (wm *WorkerManager) GetJobQueue() chan t.IAction {
	return wm.JobQueue
}

/// pass/assign_to_bitwise_pass.go ///
// Package pass implements various AST transformation passes for Go code.
package pass

import (
	"go/ast"
	"go/token"

	"github.com/rafa-mori/gastype/internal/astutil"
)

// AssignToBitwisePass converts bool field assignments to bitwise flag operations.
// Examples:
//
//	cfg.Debug = true  →  cfg.flags |= FlagDebug
//	cfg.Debug = false →  cfg.flags &^= FlagDebug
type AssignToBitwisePass struct{}

func NewAssignToBitwisePass() *AssignToBitwisePass {
	return &AssignToBitwisePass{}
}

func (p *AssignToBitwisePass) Name() string {
	return "AssignToBitwise"
}

func (p *AssignToBitwisePass) Apply(file *ast.File, fset *token.FileSet, ctx *astutil.TranspileContext) error {
	transformations := 0

	ast.Inspect(file, func(n ast.Node) bool {
		as, ok := n.(*ast.AssignStmt)
		if !ok || len(as.Lhs) != 1 || len(as.Rhs) != 1 {
			return true
		}

		// Checa se LHS é algo como cfg.Debug
		sel, ok := as.Lhs[0].(*ast.SelectorExpr)
		if !ok {
			return true
		}
		ident, ok := sel.X.(*ast.Ident)
		if !ok {
			return true
		}

		// Checa se RHS é literal true/false
		valIdent, ok := as.Rhs[0].(*ast.Ident)
		if !ok {
			return true
		}

		// Procura se o campo é um mapeado para flag
		for _, info := range ctx.Structs {
			if flagName, exists := info.FlagMapping[sel.Sel.Name]; exists {
				// Substitui o campo pelo campo "flags"
				as.Lhs[0] = &ast.SelectorExpr{
					X:   ident,
					Sel: ast.NewIdent("flags"),
				}

				if valIdent.Name == "true" {
					as.Tok = token.OR_ASSIGN
					as.Rhs[0] = ast.NewIdent(flagName)
				} else if valIdent.Name == "false" {
					as.Tok = token.AND_NOT_ASSIGN
					as.Rhs[0] = ast.NewIdent(flagName)
				} else {
					return true // não é booleano simples
				}

				transformations++

				// Registra no contexto para relatórios
				pos := fset.Position(as.Pos())
				ctx.RegisterAssignToBitwise(pos.Filename, sel.Sel.Name, flagName, valIdent.Name)

				break
			}
		}

		return true
	})

	if transformations > 0 {
		ctx.LogVerbose(nil, "🔄 AssignToBitwisePass: %d assignments converted", transformations)
	}

	return nil
}

/// pass/bool_to_flags_pass.go ///
package pass

import (
	"fmt"
	"go/ast"
	"go/token"
	"strings"

	"github.com/rafa-mori/gastype/internal/astutil"
	stdastutil "golang.org/x/tools/go/ast/astutil"
)

// BoolToFlagsPass converte campos bool em flags bitwise
type BoolToFlagsPass struct{}

func NewBoolToFlagsPass() *BoolToFlagsPass {
	return &BoolToFlagsPass{}
}

func (p *BoolToFlagsPass) Name() string {
	return "BoolToFlags"
}

func (p *BoolToFlagsPass) Apply(file *ast.File, fset *token.FileSet, ctx *astutil.TranspileContext) error {
	// Guarda mapeamento struct → campos booleanos convertidos
	convertedStructs := make(map[string][]string)

	// === 1️⃣ Identifica e converte structs com bools ===
	ast.Inspect(file, func(n ast.Node) bool {
		typeDecl, ok := n.(*ast.TypeSpec)
		if !ok {
			return true
		}

		structType, ok := typeDecl.Type.(*ast.StructType)
		if !ok {
			return true
		}

		structName := typeDecl.Name.Name
		boolFields := []string{}

		// Usa IInfo para checar tipo real
		for _, field := range structType.Fields.List {
			if len(field.Names) == 0 {
				continue
			}
			if tv, ok := ctx.GetTypes()[field.Type]; ok && tv.Type.String() == "bool" {
				for _, name := range field.Names {
					boolFields = append(boolFields, name.Name)
				}
			}
		}

		if !astutil.DeveConverterBools(len(boolFields)) {
			return true
		}

		convertedStructs[structName] = boolFields

		// Determina tipo ideal (uint8, uint16, uint32, uint64)
		flagType := astutil.MenorTipoParaFlags(len(boolFields))

		// === 2️⃣ Cria constantes AST reais ===
		constDecls := []ast.Decl{}
		for i, fieldName := range boolFields {
			constName := fmt.Sprintf("Flag%s_%s", structName, fieldName)

			constSpec := &ast.ValueSpec{
				Names: []*ast.Ident{ast.NewIdent(constName)},
				Type:  ast.NewIdent(flagType),
				Values: []ast.Expr{
					&ast.BinaryExpr{
						X:  &ast.BasicLit{Kind: token.INT, Value: "1"},
						Op: token.SHL,
						Y:  &ast.BasicLit{Kind: token.INT, Value: fmt.Sprintf("%d", i)},
					},
				},
			}

			constDecls = append(constDecls, &ast.GenDecl{
				Tok:   token.CONST,
				Specs: []ast.Spec{constSpec},
			})

			ctx.AddDef(ast.NewIdent(constName), nil)
			fmt.Printf("🏷️  Added constant: %s (%s)\n", constName, flagType)
		}
		file.Decls = append(constDecls, file.Decls...) // insere no topo

		// === 3️⃣ Substitui campo bool por "flags" ===
		newFields := []*ast.Field{
			{
				Names: []*ast.Ident{ast.NewIdent("flags")},
				Type:  ast.NewIdent(flagType),
			},
		}
		for _, field := range structType.Fields.List {
			if tv, ok := ctx.GetTypes()[field.Type]; ok && tv.Type.String() == "bool" {
				continue
			}
			newFields = append(newFields, field)
		}
		structType.Fields.List = newFields

		return true
	})

	// === 4️⃣ Substitui acessos cfg.Debug → cfg.flags & FlagStruct_Debug != 0 ===
	stdastutil.Apply(file, func(cr *stdastutil.Cursor) bool {
		sel, ok := cr.Node().(*ast.SelectorExpr)
		if !ok {
			return true
		}

		selInfo := ctx.GetSelections()[sel]
		if selInfo == nil || selInfo.Obj() == nil {
			return true
		}

		fieldName := selInfo.Obj().Name()
		if fieldName == "" {
			return true
		}

		// Verifica se o campo pertence a uma struct que foi convertida
		for structName, boolFields := range convertedStructs {
			if contains(boolFields, fieldName) {
				recvType := selInfo.Recv().String()
				if recvType == structName || recvType == "*"+structName {
					// Substituir o acesso pelo bitwise check
					cr.Replace(&ast.BinaryExpr{
						X: &ast.BinaryExpr{
							X:  &ast.SelectorExpr{X: sel.X, Sel: ast.NewIdent("flags")},
							Op: token.AND,
							Y:  ast.NewIdent(fmt.Sprintf("Flag%s_%s", structName, fieldName)),
						},
						Op: token.NEQ,
						Y:  &ast.BasicLit{Kind: token.INT, Value: "0"},
					})
				}
			}
		}

		return true
	}, nil)

	return nil
}

// contains verifica se s está em slice arr
func contains(arr []string, s string) bool {
	for _, v := range arr {
		if strings.EqualFold(v, s) {
			return true
		}
	}
	return false
}

/// pass/field_access_to_bitwise_pass.go ///
// Package pass implements various AST transformation passes for the Gastype project.
package pass

import (
	"go/ast"
	"go/token"

	"github.com/rafa-mori/gastype/internal/astutil"
)

// FieldAccessToBitwisePass transforms any field access to bitwise operations
// This covers:
// - Function arguments
// - Return values
// - Assignments
// - Standalone expressions
type FieldAccessToBitwisePass struct{}

func NewFieldAccessToBitwisePass() *FieldAccessToBitwisePass {
	return &FieldAccessToBitwisePass{}
}

func (p *FieldAccessToBitwisePass) Name() string {
	return "FieldAccessToBitwise"
}

func (p *FieldAccessToBitwisePass) Apply(file *ast.File, fset *token.FileSet, ctx *astutil.TranspileContext) error {
	transformations := 0

	ast.Inspect(file, func(n ast.Node) bool {
		switch node := n.(type) {
		case *ast.CallExpr: // function arguments
			for i, arg := range node.Args {
				if newArg := p.transformSelectorExpr(arg, ctx); newArg != nil {
					node.Args[i] = newArg
					transformations++
				}
			}

		case *ast.ReturnStmt: // return values
			for i, result := range node.Results {
				if newResult := p.transformSelectorExpr(result, ctx); newResult != nil {
					node.Results[i] = newResult
					transformations++
				}
			}

		case *ast.AssignStmt: // assignments
			for i, rhs := range node.Rhs {
				if newRhs := p.transformSelectorExpr(rhs, ctx); newRhs != nil {
					node.Rhs[i] = newRhs
					transformations++
				}
			}

		case *ast.ExprStmt: // standalone expressions (rare but possible)
			if newX := p.transformSelectorExpr(node.X, ctx); newX != nil {
				node.X = newX
				transformations++
			}
		}
		return true
	})

	if transformations > 0 {
		ctx.LogVerbose(fset, "🔄 FieldAccessToBitwisePass: %d transformations applied", transformations)
	}

	return nil
}

// transformSelectorExpr checks if an expression is a selector that needs transformation
func (p *FieldAccessToBitwisePass) transformSelectorExpr(expr ast.Expr, ctx *astutil.TranspileContext) ast.Expr {
	sel, ok := expr.(*ast.SelectorExpr)
	if !ok {
		return nil
	}

	ident := astutil.GetRootIdent(sel.X)
	if ident == nil {
		return nil
	}

	if info, exists := ctx.Structs[ident.Name]; exists {
		if flagName, ok := info.FlagMapping[sel.Sel.Name]; ok {
			return &ast.BinaryExpr{
				X: &ast.ParenExpr{
					X: &ast.BinaryExpr{
						X: &ast.SelectorExpr{
							X:   sel.X, // preserve original object
							Sel: ast.NewIdent("flags"),
						},
						Op: token.AND,
						Y:  ast.NewIdent(flagName),
					},
				},
				Op: token.NEQ,
				Y: &ast.BasicLit{
					Kind:  token.INT,
					Value: "0",
				},
			}
		}
	}

	return nil
}

/// pass/if_to_bitwise_pass.go ///
// Package pass implements various code transformations for Go ASTs.
package pass

import (
	"go/ast"
	"go/token"

	"github.com/rafa-mori/gastype/internal/astutil"
)

// IfToBitwisePass converts bool field conditions in if-statements to bitwise flag checks
// Example:
//
//	if cfg.Debug { ... }
//
// becomes:
//
//	if (cfg.flags & FlagConfig_Debug) != 0 { ... }
type IfToBitwisePass struct{}

func NewIfToBitwisePass() *IfToBitwisePass {
	return &IfToBitwisePass{}
}

func (p *IfToBitwisePass) Name() string {
	return "IfToBitwise"
}

func (p *IfToBitwisePass) Apply(file *ast.File, _ *token.FileSet, ctx *astutil.TranspileContext) error {
	transformations := 0

	ast.Inspect(file, func(n ast.Node) bool {
		ifStmt, ok := n.(*ast.IfStmt)
		if !ok {
			return true
		}

		// Verifica se a condição é um acesso a campo (SelectorExpr)
		sel, ok := ifStmt.Cond.(*ast.SelectorExpr)
		if !ok {
			return true
		}

		// O X do seletor pode ser Ident (cfg) ou algo mais complexo (ex: getCfg())
		structIdent, ok := sel.X.(*ast.Ident)
		if !ok {
			return true
		}

		// Busca no contexto se a struct tem esse campo mapeado para flag
		if info, exists := ctx.Structs[structIdent.Name]; exists {
			if flagName, ok := info.FlagMapping[sel.Sel.Name]; ok {
				// Substitui a condição do if para a checagem bitwise
				ifStmt.Cond = &ast.BinaryExpr{
					X: &ast.ParenExpr{
						X: &ast.BinaryExpr{
							X: &ast.SelectorExpr{
								X:   sel.X, // preserva o objeto original
								Sel: ast.NewIdent("flags"),
							},
							Op: token.AND,
							Y:  ast.NewIdent(flagName),
						},
					},
					Op: token.NEQ,
					Y: &ast.BasicLit{
						Kind:  token.INT,
						Value: "0",
					},
				}
				transformations++
			}
		}

		return true
	})

	if transformations > 0 {
		ctx.LogVerbose(nil, "⚡ IfToBitwisePass: %d transformations applied", transformations)
	}

	return nil
}

/// pass/jump_table_pass.go ///
// Package pass implements AST transformation passes.
package pass

import (
	"fmt"
	"go/ast"
	"go/token"
	"strconv"

	"github.com/rafa-mori/gastype/internal/astutil"
)

// JumpTablePass detects AND transforms if-else chains comparing the same variable to strings
// into an optimized jump table lookup.
type JumpTablePass struct{}

func NewJumpTablePass() *JumpTablePass {
	return &JumpTablePass{}
}

func (p *JumpTablePass) Name() string {
	return "JumpTable"
}

func (p *JumpTablePass) Apply(file *ast.File, _ *token.FileSet, ctx *astutil.TranspileContext) error {
	transformations := 0

	// Precisamos manipular a AST com substituição de nós
	astutil.ReplaceNode(file, func(n ast.Node) ast.Node {
		ifStmt, ok := n.(*ast.IfStmt)
		if !ok {
			return n
		}

		varName, branches := p.collectBranches(ifStmt)
		if varName == "" || len(branches) < 3 {
			return n // não é candidato
		}

		transformations++

		// Nome único pro jump table
		jumpTableName := fmt.Sprintf("jumpTable_%s", varName)

		// Cria o map[string]func()
		mapEntries := []ast.Expr{}

		for _, b := range branches {
			mapEntries = append(mapEntries, &ast.KeyValueExpr{
				Key: &ast.BasicLit{
					Kind:  token.STRING,
					Value: strconv.Quote(b.matchValue),
				},
				Value: &ast.FuncLit{
					Type: &ast.FuncType{
						Params:  &ast.FieldList{},
						Results: nil,
					},
					Body: b.body,
				},
			})
		}

		mapDecl := &ast.DeclStmt{
			Decl: &ast.GenDecl{
				Tok: token.VAR,
				Specs: []ast.Spec{
					&ast.ValueSpec{
						Names: []*ast.Ident{ast.NewIdent(jumpTableName)},
						Type: &ast.MapType{
							Key:   ast.NewIdent("string"),
							Value: &ast.FuncType{Params: &ast.FieldList{}},
						},
						Values: []ast.Expr{
							&ast.CompositeLit{
								Type: &ast.MapType{
									Key:   ast.NewIdent("string"),
									Value: &ast.FuncType{Params: &ast.FieldList{}},
								},
								Elts: mapEntries,
							},
						},
					},
				},
			},
		}

		// if fn, ok := jumpTable[varName]; ok { fn() }
		lookupIf := &ast.IfStmt{
			Init: &ast.AssignStmt{
				Lhs: []ast.Expr{
					ast.NewIdent("fn"),
					ast.NewIdent("ok"),
				},
				Tok: token.DEFINE,
				Rhs: []ast.Expr{
					&ast.IndexExpr{
						X:     ast.NewIdent(jumpTableName),
						Index: ast.NewIdent(varName),
					},
				},
			},
			Cond: ast.NewIdent("ok"),
			Body: &ast.BlockStmt{
				List: []ast.Stmt{
					&ast.ExprStmt{
						X: &ast.CallExpr{
							Fun: ast.NewIdent("fn"),
						},
					},
				},
			},
		}

		// Substitui o if original por: var jumpTable... + if fn,ok...
		return &ast.BlockStmt{
			List: []ast.Stmt{
				mapDecl,
				lookupIf,
			},
		}

	}(file), nil)

	if transformations > 0 {
		ctx.LogVerbose(nil, "🔀 JumpTablePass: %d transformations applied", transformations)
	}

	return nil
}

// branchInfo guarda cada case do if-chain
type branchInfo struct {
	matchValue string
	body       *ast.BlockStmt
}

// collectBranches lê a cadeia if-else-if e retorna o nome da var e todos os cases
func (p *JumpTablePass) collectBranches(ifStmt *ast.IfStmt) (string, []branchInfo) {
	branches := []branchInfo{}
	var varName string

	current := ifStmt
	for current != nil {
		binExpr, ok := current.Cond.(*ast.BinaryExpr)
		if !ok || binExpr.Op != token.EQL {
			break
		}

		leftIdent, ok := binExpr.X.(*ast.Ident)
		if !ok {
			break
		}
		if varName == "" {
			varName = leftIdent.Name
		} else if leftIdent.Name != varName {
			break
		}

		rightLit, ok := binExpr.Y.(*ast.BasicLit)
		if !ok || rightLit.Kind != token.STRING {
			break
		}

		branches = append(branches, branchInfo{
			matchValue: rightLit.Value[1 : len(rightLit.Value)-1], // remove aspas
			body:       current.Body,
		})

		if nextIf, ok := current.Else.(*ast.IfStmt); ok {
			current = nextIf
		} else {
			break
		}
	}

	return varName, branches
}

/// pass/string_obfuscate_pass.go ///
package pass

import (
	"fmt"
	"go/ast"
	"go/token"
	"strconv"
	"strings"

	"github.com/rafa-mori/gastype/internal/astutil"
)

type StringObfuscatePass struct{}

func NewStringObfuscatePass() *StringObfuscatePass { return &StringObfuscatePass{} }
func (p *StringObfuscatePass) Name() string        { return "StringObfuscate" }

func (p *StringObfuscatePass) Apply(file *ast.File, _ *token.FileSet, ctx *astutil.TranspileContext) error {
	transformations := 0

	// Imports → ignorar
	importSpecs := make(map[*ast.BasicLit]bool)
	for _, decl := range file.Decls {
		if gd, ok := decl.(*ast.GenDecl); ok && gd.Tok == token.IMPORT {
			for _, spec := range gd.Specs {
				if is, ok := spec.(*ast.ImportSpec); ok && is.Path != nil {
					importSpecs[is.Path] = true
				}
			}
		}
	}

	// Constantes string
	constStrings := make(map[*ast.BasicLit]string)

	for _, decl := range file.Decls {
		gd, ok := decl.(*ast.GenDecl)
		if !ok || gd.Tok != token.CONST {
			continue
		}

		for _, spec := range gd.Specs {
			vs, ok := spec.(*ast.ValueSpec)
			if !ok || len(vs.Names) == 0 {
				continue
			}

			// Se não for string-like → ignora
			if !astutil.DetectStringLikeConst(vs, ctx) {
				continue
			}

			// Nome da constante
			name := vs.Names[0].Name

			// Se já tiver valor literal, guarda pra obfuscar
			if len(vs.Values) > 0 {
				if bl, ok := vs.Values[0].(*ast.BasicLit); ok && bl.Kind == token.STRING {
					constStrings[bl] = name
				}
			} else {
				// Caso não tenha valor literal (ex: alias sem inicialização), ainda é string-like
				// mas não vamos mexer agora
				fmt.Printf("  ℹ️ Found string alias constant without literal: %s\n", name)
			}
		}
	}

	// Tags de struct → ignorar
	structTags := make(map[*ast.BasicLit]bool)
	ast.Inspect(file, func(n ast.Node) bool {
		if f, ok := n.(*ast.Field); ok && f.Tag != nil {
			structTags[f.Tag] = true
		}
		return true
	})

	var initStmts []ast.Stmt

	// Percorre a AST e obfusca strings
	ast.Inspect(file, func(n ast.Node) bool {

		bl, ok := n.(*ast.BasicLit)
		if !ok || bl.Kind != token.STRING {
			return true
		}
		if importSpecs[bl] || structTags[bl] {
			return true
		}

		val, err := strconv.Unquote(bl.Value)
		if err != nil || len(val) < 4 {
			return true
		}

		commonWords := []string{"main", "func", "package", "import", "var", "const", "if", "else", "for", "range"}
		for _, w := range commonWords {
			if val == w {
				return true
			}
		}

		// Obfuscação → byte array
		byteVals := make([]string, len(val))
		for i, b := range []byte(val) {
			byteVals[i] = strconv.Itoa(int(b))
		}

		// Caso seja constante → converte para var + init()
		if constName, isConst := constStrings[bl]; isConst {
			// Valida se é alias de string
			if !astutil.DetectStringLikeConst(&ast.ValueSpec{
				Names:  []*ast.Ident{ast.NewIdent(constName)},
				Values: []ast.Expr{},
				Type:   ast.NewIdent("string"),
			}, ctx) {
				if isConst {
					// Se for alias de string, não faz nada
					// bl.Value = constName
					// bl.Kind = token.IDENT
					return true
				} else {
					// Não é alias, converte para var
					// Substitui declaração const por var
					for _, decl := range file.Decls {
						if gd, ok := decl.(*ast.GenDecl); ok && gd.Tok == token.CONST {
							for i, spec := range gd.Specs {
								vs, ok := spec.(*ast.ValueSpec)
								if !ok || len(vs.Names) == 0 || vs.Names[0].Name != constName {
									continue
								}
								gd.Tok = token.VAR
								gd.Specs[i] = vs
								break
							}
						}
					}
				}
				// fmt.Printf("  ℹ️ Converted const to var: %s\n", constName)
			} else {
				// Gera const com array de bytes no init()
				initStmts = append(initStmts, &ast.AssignStmt{
					Lhs: []ast.Expr{ast.NewIdent(constName)},
					Tok: token.ASSIGN,
					Rhs: []ast.Expr{
						&ast.CallExpr{
							Fun: ast.NewIdent("string"),
							Args: []ast.Expr{
								&ast.CompositeLit{
									Type: &ast.ArrayType{Elt: ast.NewIdent("byte")},
									Elts: func() []ast.Expr {
										elts := []ast.Expr{}
										for _, b := range []byte(val) {
											elts = append(elts, &ast.BasicLit{
												Kind:  token.INT,
												Value: strconv.Itoa(int(b)),
											})
										}
										return elts
									}(),
								},
							},
						},
					},
				})
				transformations++
				return true
			}

		}

		if !bl.Kind.IsLiteral() {
			// Caso literal → inline
			bl.Value = fmt.Sprintf("string([]byte{%s})", strings.Join(byteVals, ", "))
			transformations++
			return true
		}

		return false
	})

	if len(initStmts) > 0 {
		file.Decls = append(file.Decls, &ast.FuncDecl{
			Name: ast.NewIdent("init"),
			Type: &ast.FuncType{Params: &ast.FieldList{}},
			Body: &ast.BlockStmt{List: initStmts},
		})
	}

	if transformations > 0 {
		fmt.Printf("  🔄 StringObfuscatePass: %d transformations applied\n", transformations)
	}

	return nil
}
