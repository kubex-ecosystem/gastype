
# Isso aqui abaixo são algumas respostas que eu dei no chat e consegui recuperar

```plaintext
Então cara, agradeço e ADMIREI MUUUITO MESMO sua postura agora, mas assim, eu tenho um QI alto, eu aprendo muito rápido e sobre o período acadêmico, eu costumo estudar lendo é código fonte de projetos maiores e tudo mais.. kkkkkkkkk (sou meio estranho/doido)

Então vamo meter é bronca no projeto piloto mesmo... REAL. Só pedi a consistência e tudo mais pra evitar "alucinações" e coisas tão "além" do propósito que talvez até me impeçam de prosseguir com ele ou dificultariam minha interpretação/leitura da coisa.. kkkkk 

No mais, pega aí o GASType e já atua, ele tá versionado legal, é sem risco as alteraçãoes que faremos... hehehe Eu só ainda não consegui pensar (nem tive tempo de estudar) como farei para criar/gerar a análise, a "coisa" com o código de um projeto qualquer com AST que permita esse tipo de operação.. hehehe

MANDA VER!!! To aqui com TODOS meus neurônios hiper atentos e atuando contigo!
```

```plaintext
Seria interessante a gente atuar agora SOMENTE nesse escopo, sem envolver o Gobe e o resto dos projetos... Até pra manter a clareza da SEPARAÇÃO TOTAL DE ESCOPOS, PROPÓSITOS E PROJETOS MESMO..rsrs
```

````plaintext
cara...
"Criar um sistema que transpila um projeto Go COMPLETO (com todas as pastas, arquivos, dependências)" ISSO É O PROPÓSITO FINAL DA COISA!!! KKKK Se achar que o projeto já tá "pronto" pra isso, então bora nessa! kkkkkk
```

```plaintext
cara... acho que ainda falta muito pra ficar "full"... tipo você chegou a ler o "manifesto/blueprint" fullzaão? 

A ideia não é somente e diretamente o bitwise, a ideia é REALMENTE fazer uma transpilação de uma lógica convencional em Go para uma lógica que seja baseada, não totalmente, mas onde for possível, no uso do mínimo de bits possível EEEE fazer do bitwise uma espécie de operador prioritário na operação do código transpilado... Assim a gente faria os módulos go transpilados serem tipo SURREAIS até mesmo pra Go e toda sua "leveza" e performance... hahahahah

Então, pra isso ser possível com lógicas mais "complexas", a gente usaria análize e manipulação por AST, pra tentar "consolidar contextos transpiláveis" e os não "transpiláveis",. Os "consolidados/agrupamento lógico" passíveis de serem "substituidos" por flags e estados no mínimo de bits pelo transpiler seriam transpilados e os que não fossem tão simples ou não fosse possível de transpilar, a gente teria que "adequar" para funcionarem com o resto do código que foi transpilado.. emtemde? pra pessoa fazer a operação, BUILDAR O PROJETO normalmente e conseguir USAR ELE, sem ver "diferença" no fluxo que ela teria implementado.. hhahahahahahaha

Saca??? O que sugere pra seguir com esse propósito?
```
